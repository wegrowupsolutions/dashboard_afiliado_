{
  "version": 3,
  "sources": ["../../react-resizable-panels/dist/react-resizable-panels.browser.development.esm.js"],
  "sourcesContent": ["import * as React from 'react';\r\nimport { createContext, useLayoutEffect, useRef, forwardRef, createElement, useContext, useImperativeHandle, useState, useCallback, useEffect, useMemo } from 'react';\r\n\r\n// The \"contextmenu\" event is not supported as a PointerEvent in all browsers yet, so MouseEvent still need to be handled\r\n\r\nconst PanelGroupContext = createContext(null);\r\nPanelGroupContext.displayName = \"PanelGroupContext\";\r\n\r\nconst DATA_ATTRIBUTES = {\r\n  group: \"data-panel-group\",\r\n  groupDirection: \"data-panel-group-direction\",\r\n  groupId: \"data-panel-group-id\",\r\n  panel: \"data-panel\",\r\n  panelCollapsible: \"data-panel-collapsible\",\r\n  panelId: \"data-panel-id\",\r\n  panelSize: \"data-panel-size\",\r\n  resizeHandle: \"data-resize-handle\",\r\n  resizeHandleActive: \"data-resize-handle-active\",\r\n  resizeHandleEnabled: \"data-panel-resize-handle-enabled\",\r\n  resizeHandleId: \"data-panel-resize-handle-id\",\r\n  resizeHandleState: \"data-resize-handle-state\"\r\n};\r\nconst PRECISION = 10;\r\n\r\nconst useIsomorphicLayoutEffect = useLayoutEffect ;\r\n\r\nconst useId = React[\"useId\".toString()];\r\nconst wrappedUseId = typeof useId === \"function\" ? useId : () => null;\r\nlet counter = 0;\r\nfunction useUniqueId(idFromParams = null) {\r\n  const idFromUseId = wrappedUseId();\r\n  const idRef = useRef(idFromParams || idFromUseId || null);\r\n  if (idRef.current === null) {\r\n    idRef.current = \"\" + counter++;\r\n  }\r\n  return idFromParams !== null && idFromParams !== void 0 ? idFromParams : idRef.current;\r\n}\r\n\r\nfunction PanelWithForwardedRef({\r\n  children,\r\n  className: classNameFromProps = \"\",\r\n  collapsedSize,\r\n  collapsible,\r\n  defaultSize,\r\n  forwardedRef,\r\n  id: idFromProps,\r\n  maxSize,\r\n  minSize,\r\n  onCollapse,\r\n  onExpand,\r\n  onResize,\r\n  order,\r\n  style: styleFromProps,\r\n  tagName: Type = \"div\",\r\n  ...rest\r\n}) {\r\n  const context = useContext(PanelGroupContext);\r\n  if (context === null) {\r\n    throw Error(`Panel components must be rendered within a PanelGroup container`);\r\n  }\r\n  const {\r\n    collapsePanel,\r\n    expandPanel,\r\n    getPanelSize,\r\n    getPanelStyle,\r\n    groupId,\r\n    isPanelCollapsed,\r\n    reevaluatePanelConstraints,\r\n    registerPanel,\r\n    resizePanel,\r\n    unregisterPanel\r\n  } = context;\r\n  const panelId = useUniqueId(idFromProps);\r\n  const panelDataRef = useRef({\r\n    callbacks: {\r\n      onCollapse,\r\n      onExpand,\r\n      onResize\r\n    },\r\n    constraints: {\r\n      collapsedSize,\r\n      collapsible,\r\n      defaultSize,\r\n      maxSize,\r\n      minSize\r\n    },\r\n    id: panelId,\r\n    idIsFromProps: idFromProps !== undefined,\r\n    order\r\n  });\r\n  const devWarningsRef = useRef({\r\n    didLogMissingDefaultSizeWarning: false\r\n  });\r\n\r\n  // Normally we wouldn't log a warning during render,\r\n  // but effects don't run on the server, so we can't do it there\r\n  {\r\n    if (!devWarningsRef.current.didLogMissingDefaultSizeWarning) ;\r\n  }\r\n  useIsomorphicLayoutEffect(() => {\r\n    const {\r\n      callbacks,\r\n      constraints\r\n    } = panelDataRef.current;\r\n    const prevConstraints = {\r\n      ...constraints\r\n    };\r\n    panelDataRef.current.id = panelId;\r\n    panelDataRef.current.idIsFromProps = idFromProps !== undefined;\r\n    panelDataRef.current.order = order;\r\n    callbacks.onCollapse = onCollapse;\r\n    callbacks.onExpand = onExpand;\r\n    callbacks.onResize = onResize;\r\n    constraints.collapsedSize = collapsedSize;\r\n    constraints.collapsible = collapsible;\r\n    constraints.defaultSize = defaultSize;\r\n    constraints.maxSize = maxSize;\r\n    constraints.minSize = minSize;\r\n\r\n    // If constraints have changed, we should revisit panel sizes.\r\n    // This is uncommon but may happen if people are trying to implement pixel based constraints.\r\n    if (prevConstraints.collapsedSize !== constraints.collapsedSize || prevConstraints.collapsible !== constraints.collapsible || prevConstraints.maxSize !== constraints.maxSize || prevConstraints.minSize !== constraints.minSize) {\r\n      reevaluatePanelConstraints(panelDataRef.current, prevConstraints);\r\n    }\r\n  });\r\n  useIsomorphicLayoutEffect(() => {\r\n    const panelData = panelDataRef.current;\r\n    registerPanel(panelData);\r\n    return () => {\r\n      unregisterPanel(panelData);\r\n    };\r\n  }, [order, panelId, registerPanel, unregisterPanel]);\r\n  useImperativeHandle(forwardedRef, () => ({\r\n    collapse: () => {\r\n      collapsePanel(panelDataRef.current);\r\n    },\r\n    expand: minSize => {\r\n      expandPanel(panelDataRef.current, minSize);\r\n    },\r\n    getId() {\r\n      return panelId;\r\n    },\r\n    getSize() {\r\n      return getPanelSize(panelDataRef.current);\r\n    },\r\n    isCollapsed() {\r\n      return isPanelCollapsed(panelDataRef.current);\r\n    },\r\n    isExpanded() {\r\n      return !isPanelCollapsed(panelDataRef.current);\r\n    },\r\n    resize: size => {\r\n      resizePanel(panelDataRef.current, size);\r\n    }\r\n  }), [collapsePanel, expandPanel, getPanelSize, isPanelCollapsed, panelId, resizePanel]);\r\n  const style = getPanelStyle(panelDataRef.current, defaultSize);\r\n  return createElement(Type, {\r\n    ...rest,\r\n    children,\r\n    className: classNameFromProps,\r\n    id: panelId,\r\n    style: {\r\n      ...style,\r\n      ...styleFromProps\r\n    },\r\n    // CSS selectors\r\n    [DATA_ATTRIBUTES.groupId]: groupId,\r\n    [DATA_ATTRIBUTES.panel]: \"\",\r\n    [DATA_ATTRIBUTES.panelCollapsible]: collapsible || undefined,\r\n    [DATA_ATTRIBUTES.panelId]: panelId,\r\n    [DATA_ATTRIBUTES.panelSize]: parseFloat(\"\" + style.flexGrow).toFixed(1)\r\n  });\r\n}\r\nconst Panel = forwardRef((props, ref) => createElement(PanelWithForwardedRef, {\r\n  ...props,\r\n  forwardedRef: ref\r\n}));\r\nPanelWithForwardedRef.displayName = \"Panel\";\r\nPanel.displayName = \"forwardRef(Panel)\";\r\n\r\nlet nonce;\r\nfunction getNonce() {\r\n  return nonce;\r\n}\r\nfunction setNonce(value) {\r\n  nonce = value;\r\n}\r\n\r\nlet currentCursorStyle = null;\r\nlet enabled = true;\r\nlet prevRuleIndex = -1;\r\nlet styleElement = null;\r\nfunction disableGlobalCursorStyles() {\r\n  enabled = false;\r\n}\r\nfunction enableGlobalCursorStyles() {\r\n  enabled = true;\r\n}\r\nfunction getCursorStyle(state, constraintFlags) {\r\n  if (constraintFlags) {\r\n    const horizontalMin = (constraintFlags & EXCEEDED_HORIZONTAL_MIN) !== 0;\r\n    const horizontalMax = (constraintFlags & EXCEEDED_HORIZONTAL_MAX) !== 0;\r\n    const verticalMin = (constraintFlags & EXCEEDED_VERTICAL_MIN) !== 0;\r\n    const verticalMax = (constraintFlags & EXCEEDED_VERTICAL_MAX) !== 0;\r\n    if (horizontalMin) {\r\n      if (verticalMin) {\r\n        return \"se-resize\";\r\n      } else if (verticalMax) {\r\n        return \"ne-resize\";\r\n      } else {\r\n        return \"e-resize\";\r\n      }\r\n    } else if (horizontalMax) {\r\n      if (verticalMin) {\r\n        return \"sw-resize\";\r\n      } else if (verticalMax) {\r\n        return \"nw-resize\";\r\n      } else {\r\n        return \"w-resize\";\r\n      }\r\n    } else if (verticalMin) {\r\n      return \"s-resize\";\r\n    } else if (verticalMax) {\r\n      return \"n-resize\";\r\n    }\r\n  }\r\n  switch (state) {\r\n    case \"horizontal\":\r\n      return \"ew-resize\";\r\n    case \"intersection\":\r\n      return \"move\";\r\n    case \"vertical\":\r\n      return \"ns-resize\";\r\n  }\r\n}\r\nfunction resetGlobalCursorStyle() {\r\n  if (styleElement !== null) {\r\n    document.head.removeChild(styleElement);\r\n    currentCursorStyle = null;\r\n    styleElement = null;\r\n    prevRuleIndex = -1;\r\n  }\r\n}\r\nfunction setGlobalCursorStyle(state, constraintFlags) {\r\n  var _styleElement$sheet$i, _styleElement$sheet2;\r\n  if (!enabled) {\r\n    return;\r\n  }\r\n  const style = getCursorStyle(state, constraintFlags);\r\n  if (currentCursorStyle === style) {\r\n    return;\r\n  }\r\n  currentCursorStyle = style;\r\n  if (styleElement === null) {\r\n    styleElement = document.createElement(\"style\");\r\n    const nonce = getNonce();\r\n    if (nonce) {\r\n      styleElement.setAttribute(\"nonce\", nonce);\r\n    }\r\n    document.head.appendChild(styleElement);\r\n  }\r\n  if (prevRuleIndex >= 0) {\r\n    var _styleElement$sheet;\r\n    (_styleElement$sheet = styleElement.sheet) === null || _styleElement$sheet === void 0 ? void 0 : _styleElement$sheet.removeRule(prevRuleIndex);\r\n  }\r\n  prevRuleIndex = (_styleElement$sheet$i = (_styleElement$sheet2 = styleElement.sheet) === null || _styleElement$sheet2 === void 0 ? void 0 : _styleElement$sheet2.insertRule(`*{cursor: ${style} !important;}`)) !== null && _styleElement$sheet$i !== void 0 ? _styleElement$sheet$i : -1;\r\n}\r\n\r\nfunction isKeyDown(event) {\r\n  return event.type === \"keydown\";\r\n}\r\nfunction isPointerEvent(event) {\r\n  return event.type.startsWith(\"pointer\");\r\n}\r\nfunction isMouseEvent(event) {\r\n  return event.type.startsWith(\"mouse\");\r\n}\r\n\r\nfunction getResizeEventCoordinates(event) {\r\n  if (isPointerEvent(event)) {\r\n    if (event.isPrimary) {\r\n      return {\r\n        x: event.clientX,\r\n        y: event.clientY\r\n      };\r\n    }\r\n  } else if (isMouseEvent(event)) {\r\n    return {\r\n      x: event.clientX,\r\n      y: event.clientY\r\n    };\r\n  }\r\n  return {\r\n    x: Infinity,\r\n    y: Infinity\r\n  };\r\n}\r\n\r\nfunction getInputType() {\r\n  if (typeof matchMedia === \"function\") {\r\n    return matchMedia(\"(pointer:coarse)\").matches ? \"coarse\" : \"fine\";\r\n  }\r\n}\r\n\r\nfunction intersects(rectOne, rectTwo, strict) {\r\n  if (strict) {\r\n    return rectOne.x < rectTwo.x + rectTwo.width && rectOne.x + rectOne.width > rectTwo.x && rectOne.y < rectTwo.y + rectTwo.height && rectOne.y + rectOne.height > rectTwo.y;\r\n  } else {\r\n    return rectOne.x <= rectTwo.x + rectTwo.width && rectOne.x + rectOne.width >= rectTwo.x && rectOne.y <= rectTwo.y + rectTwo.height && rectOne.y + rectOne.height >= rectTwo.y;\r\n  }\r\n}\r\n\r\n// Forked from NPM stacking-order@2.0.0\r\n\r\n/**\r\n * Determine which of two nodes appears in front of the other —\r\n * if `a` is in front, returns 1, otherwise returns -1\r\n * @param {HTMLElement | SVGElement} a\r\n * @param {HTMLElement | SVGElement} b\r\n */\r\nfunction compare(a, b) {\r\n  if (a === b) throw new Error(\"Cannot compare node with itself\");\r\n  const ancestors = {\r\n    a: get_ancestors(a),\r\n    b: get_ancestors(b)\r\n  };\r\n  let common_ancestor;\r\n\r\n  // remove shared ancestors\r\n  while (ancestors.a.at(-1) === ancestors.b.at(-1)) {\r\n    a = ancestors.a.pop();\r\n    b = ancestors.b.pop();\r\n    common_ancestor = a;\r\n  }\r\n  assert(common_ancestor, \"Stacking order can only be calculated for elements with a common ancestor\");\r\n  const z_indexes = {\r\n    a: get_z_index(find_stacking_context(ancestors.a)),\r\n    b: get_z_index(find_stacking_context(ancestors.b))\r\n  };\r\n  if (z_indexes.a === z_indexes.b) {\r\n    const children = common_ancestor.childNodes;\r\n    const furthest_ancestors = {\r\n      a: ancestors.a.at(-1),\r\n      b: ancestors.b.at(-1)\r\n    };\r\n    let i = children.length;\r\n    while (i--) {\r\n      const child = children[i];\r\n      if (child === furthest_ancestors.a) return 1;\r\n      if (child === furthest_ancestors.b) return -1;\r\n    }\r\n  }\r\n  return Math.sign(z_indexes.a - z_indexes.b);\r\n}\r\nconst props = /\\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\\b/;\r\n\r\n/** @param {HTMLElement | SVGElement} node */\r\nfunction is_flex_item(node) {\r\n  var _get_parent;\r\n  // @ts-ignore\r\n  const display = getComputedStyle((_get_parent = get_parent(node)) !== null && _get_parent !== void 0 ? _get_parent : node).display;\r\n  return display === \"flex\" || display === \"inline-flex\";\r\n}\r\n\r\n/** @param {HTMLElement | SVGElement} node */\r\nfunction creates_stacking_context(node) {\r\n  const style = getComputedStyle(node);\r\n\r\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Positioning/Understanding_z_index/The_stacking_context\r\n  if (style.position === \"fixed\") return true;\r\n  // Forked to fix upstream bug https://github.com/Rich-Harris/stacking-order/issues/3\r\n  // if (\r\n  //   (style.zIndex !== \"auto\" && style.position !== \"static\") ||\r\n  //   is_flex_item(node)\r\n  // )\r\n  if (style.zIndex !== \"auto\" && (style.position !== \"static\" || is_flex_item(node))) return true;\r\n  if (+style.opacity < 1) return true;\r\n  if (\"transform\" in style && style.transform !== \"none\") return true;\r\n  if (\"webkitTransform\" in style && style.webkitTransform !== \"none\") return true;\r\n  if (\"mixBlendMode\" in style && style.mixBlendMode !== \"normal\") return true;\r\n  if (\"filter\" in style && style.filter !== \"none\") return true;\r\n  if (\"webkitFilter\" in style && style.webkitFilter !== \"none\") return true;\r\n  if (\"isolation\" in style && style.isolation === \"isolate\") return true;\r\n  if (props.test(style.willChange)) return true;\r\n  // @ts-expect-error\r\n  if (style.webkitOverflowScrolling === \"touch\") return true;\r\n  return false;\r\n}\r\n\r\n/** @param {(HTMLElement| SVGElement)[]} nodes */\r\nfunction find_stacking_context(nodes) {\r\n  let i = nodes.length;\r\n  while (i--) {\r\n    const node = nodes[i];\r\n    assert(node, \"Missing node\");\r\n    if (creates_stacking_context(node)) return node;\r\n  }\r\n  return null;\r\n}\r\n\r\n/** @param {HTMLElement | SVGElement} node */\r\nfunction get_z_index(node) {\r\n  return node && Number(getComputedStyle(node).zIndex) || 0;\r\n}\r\n\r\n/** @param {HTMLElement} node */\r\nfunction get_ancestors(node) {\r\n  const ancestors = [];\r\n  while (node) {\r\n    ancestors.push(node);\r\n    // @ts-ignore\r\n    node = get_parent(node);\r\n  }\r\n  return ancestors; // [ node, ... <body>, <html>, document ]\r\n}\r\n\r\n/** @param {HTMLElement} node */\r\nfunction get_parent(node) {\r\n  const {\r\n    parentNode\r\n  } = node;\r\n  if (parentNode && parentNode instanceof ShadowRoot) {\r\n    return parentNode.host;\r\n  }\r\n  return parentNode;\r\n}\r\n\r\nconst EXCEEDED_HORIZONTAL_MIN = 0b0001;\r\nconst EXCEEDED_HORIZONTAL_MAX = 0b0010;\r\nconst EXCEEDED_VERTICAL_MIN = 0b0100;\r\nconst EXCEEDED_VERTICAL_MAX = 0b1000;\r\nconst isCoarsePointer = getInputType() === \"coarse\";\r\nlet intersectingHandles = [];\r\nlet isPointerDown = false;\r\nlet ownerDocumentCounts = new Map();\r\nlet panelConstraintFlags = new Map();\r\nconst registeredResizeHandlers = new Set();\r\nfunction registerResizeHandle(resizeHandleId, element, direction, hitAreaMargins, setResizeHandlerState) {\r\n  var _ownerDocumentCounts$;\r\n  const {\r\n    ownerDocument\r\n  } = element;\r\n  const data = {\r\n    direction,\r\n    element,\r\n    hitAreaMargins,\r\n    setResizeHandlerState\r\n  };\r\n  const count = (_ownerDocumentCounts$ = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$ !== void 0 ? _ownerDocumentCounts$ : 0;\r\n  ownerDocumentCounts.set(ownerDocument, count + 1);\r\n  registeredResizeHandlers.add(data);\r\n  updateListeners();\r\n  return function unregisterResizeHandle() {\r\n    var _ownerDocumentCounts$2;\r\n    panelConstraintFlags.delete(resizeHandleId);\r\n    registeredResizeHandlers.delete(data);\r\n    const count = (_ownerDocumentCounts$2 = ownerDocumentCounts.get(ownerDocument)) !== null && _ownerDocumentCounts$2 !== void 0 ? _ownerDocumentCounts$2 : 1;\r\n    ownerDocumentCounts.set(ownerDocument, count - 1);\r\n    updateListeners();\r\n    if (count === 1) {\r\n      ownerDocumentCounts.delete(ownerDocument);\r\n    }\r\n\r\n    // If the resize handle that is currently unmounting is intersecting with the pointer,\r\n    // update the global pointer to account for the change\r\n    if (intersectingHandles.includes(data)) {\r\n      const index = intersectingHandles.indexOf(data);\r\n      if (index >= 0) {\r\n        intersectingHandles.splice(index, 1);\r\n      }\r\n      updateCursor();\r\n\r\n      // Also instruct the handle to stop dragging; this prevents the parent group from being left in an inconsistent state\r\n      // See github.com/bvaughn/react-resizable-panels/issues/402\r\n      setResizeHandlerState(\"up\", true, null);\r\n    }\r\n  };\r\n}\r\nfunction handlePointerDown(event) {\r\n  const {\r\n    target\r\n  } = event;\r\n  const {\r\n    x,\r\n    y\r\n  } = getResizeEventCoordinates(event);\r\n  isPointerDown = true;\r\n  recalculateIntersectingHandles({\r\n    target,\r\n    x,\r\n    y\r\n  });\r\n  updateListeners();\r\n  if (intersectingHandles.length > 0) {\r\n    updateResizeHandlerStates(\"down\", event);\r\n    event.preventDefault();\r\n    if (!isWithinResizeHandle(target)) {\r\n      event.stopImmediatePropagation();\r\n    }\r\n  }\r\n}\r\nfunction handlePointerMove(event) {\r\n  const {\r\n    x,\r\n    y\r\n  } = getResizeEventCoordinates(event);\r\n\r\n  // Edge case (see #340)\r\n  // Detect when the pointer has been released outside an iframe on a different domain\r\n  if (isPointerDown && event.buttons === 0) {\r\n    isPointerDown = false;\r\n    updateResizeHandlerStates(\"up\", event);\r\n  }\r\n  if (!isPointerDown) {\r\n    const {\r\n      target\r\n    } = event;\r\n\r\n    // Recalculate intersecting handles whenever the pointer moves, except if it has already been pressed\r\n    // at that point, the handles may not move with the pointer (depending on constraints)\r\n    // but the same set of active handles should be locked until the pointer is released\r\n    recalculateIntersectingHandles({\r\n      target,\r\n      x,\r\n      y\r\n    });\r\n  }\r\n  updateResizeHandlerStates(\"move\", event);\r\n\r\n  // Update cursor based on return value(s) from active handles\r\n  updateCursor();\r\n  if (intersectingHandles.length > 0) {\r\n    event.preventDefault();\r\n  }\r\n}\r\nfunction handlePointerUp(event) {\r\n  const {\r\n    target\r\n  } = event;\r\n  const {\r\n    x,\r\n    y\r\n  } = getResizeEventCoordinates(event);\r\n  panelConstraintFlags.clear();\r\n  isPointerDown = false;\r\n  if (intersectingHandles.length > 0) {\r\n    event.preventDefault();\r\n    if (!isWithinResizeHandle(target)) {\r\n      event.stopImmediatePropagation();\r\n    }\r\n  }\r\n  updateResizeHandlerStates(\"up\", event);\r\n  recalculateIntersectingHandles({\r\n    target,\r\n    x,\r\n    y\r\n  });\r\n  updateCursor();\r\n  updateListeners();\r\n}\r\nfunction isWithinResizeHandle(element) {\r\n  let currentElement = element;\r\n  while (currentElement) {\r\n    if (currentElement.hasAttribute(DATA_ATTRIBUTES.resizeHandle)) {\r\n      return true;\r\n    }\r\n    currentElement = currentElement.parentElement;\r\n  }\r\n  return false;\r\n}\r\nfunction recalculateIntersectingHandles({\r\n  target,\r\n  x,\r\n  y\r\n}) {\r\n  intersectingHandles.splice(0);\r\n  let targetElement = null;\r\n  if (target instanceof HTMLElement || target instanceof SVGElement) {\r\n    targetElement = target;\r\n  }\r\n  registeredResizeHandlers.forEach(data => {\r\n    const {\r\n      element: dragHandleElement,\r\n      hitAreaMargins\r\n    } = data;\r\n    const dragHandleRect = dragHandleElement.getBoundingClientRect();\r\n    const {\r\n      bottom,\r\n      left,\r\n      right,\r\n      top\r\n    } = dragHandleRect;\r\n    const margin = isCoarsePointer ? hitAreaMargins.coarse : hitAreaMargins.fine;\r\n    const eventIntersects = x >= left - margin && x <= right + margin && y >= top - margin && y <= bottom + margin;\r\n    if (eventIntersects) {\r\n      // TRICKY\r\n      // We listen for pointers events at the root in order to support hit area margins\r\n      // (determining when the pointer is close enough to an element to be considered a \"hit\")\r\n      // Clicking on an element \"above\" a handle (e.g. a modal) should prevent a hit though\r\n      // so at this point we need to compare stacking order of a potentially intersecting drag handle,\r\n      // and the element that was actually clicked/touched\r\n      if (targetElement !== null && document.contains(targetElement) && dragHandleElement !== targetElement && !dragHandleElement.contains(targetElement) && !targetElement.contains(dragHandleElement) &&\r\n      // Calculating stacking order has a cost, so we should avoid it if possible\r\n      // That is why we only check potentially intersecting handles,\r\n      // and why we skip if the event target is within the handle's DOM\r\n      compare(targetElement, dragHandleElement) > 0) {\r\n        // If the target is above the drag handle, then we also need to confirm they overlap\r\n        // If they are beside each other (e.g. a panel and its drag handle) then the handle is still interactive\r\n        //\r\n        // It's not enough to compare only the target\r\n        // The target might be a small element inside of a larger container\r\n        // (For example, a SPAN or a DIV inside of a larger modal dialog)\r\n        let currentElement = targetElement;\r\n        let didIntersect = false;\r\n        while (currentElement) {\r\n          if (currentElement.contains(dragHandleElement)) {\r\n            break;\r\n          } else if (intersects(currentElement.getBoundingClientRect(), dragHandleRect, true)) {\r\n            didIntersect = true;\r\n            break;\r\n          }\r\n          currentElement = currentElement.parentElement;\r\n        }\r\n        if (didIntersect) {\r\n          return;\r\n        }\r\n      }\r\n      intersectingHandles.push(data);\r\n    }\r\n  });\r\n}\r\nfunction reportConstraintsViolation(resizeHandleId, flag) {\r\n  panelConstraintFlags.set(resizeHandleId, flag);\r\n}\r\nfunction updateCursor() {\r\n  let intersectsHorizontal = false;\r\n  let intersectsVertical = false;\r\n  intersectingHandles.forEach(data => {\r\n    const {\r\n      direction\r\n    } = data;\r\n    if (direction === \"horizontal\") {\r\n      intersectsHorizontal = true;\r\n    } else {\r\n      intersectsVertical = true;\r\n    }\r\n  });\r\n  let constraintFlags = 0;\r\n  panelConstraintFlags.forEach(flag => {\r\n    constraintFlags |= flag;\r\n  });\r\n  if (intersectsHorizontal && intersectsVertical) {\r\n    setGlobalCursorStyle(\"intersection\", constraintFlags);\r\n  } else if (intersectsHorizontal) {\r\n    setGlobalCursorStyle(\"horizontal\", constraintFlags);\r\n  } else if (intersectsVertical) {\r\n    setGlobalCursorStyle(\"vertical\", constraintFlags);\r\n  } else {\r\n    resetGlobalCursorStyle();\r\n  }\r\n}\r\nlet listenersAbortController = new AbortController();\r\nfunction updateListeners() {\r\n  listenersAbortController.abort();\r\n  listenersAbortController = new AbortController();\r\n  const options = {\r\n    capture: true,\r\n    signal: listenersAbortController.signal\r\n  };\r\n  if (!registeredResizeHandlers.size) {\r\n    return;\r\n  }\r\n  if (isPointerDown) {\r\n    if (intersectingHandles.length > 0) {\r\n      ownerDocumentCounts.forEach((count, ownerDocument) => {\r\n        const {\r\n          body\r\n        } = ownerDocument;\r\n        if (count > 0) {\r\n          body.addEventListener(\"contextmenu\", handlePointerUp, options);\r\n          body.addEventListener(\"pointerleave\", handlePointerMove, options);\r\n          body.addEventListener(\"pointermove\", handlePointerMove, options);\r\n        }\r\n      });\r\n    }\r\n    window.addEventListener(\"pointerup\", handlePointerUp, options);\r\n    window.addEventListener(\"pointercancel\", handlePointerUp, options);\r\n  } else {\r\n    ownerDocumentCounts.forEach((count, ownerDocument) => {\r\n      const {\r\n        body\r\n      } = ownerDocument;\r\n      if (count > 0) {\r\n        body.addEventListener(\"pointerdown\", handlePointerDown, options);\r\n        body.addEventListener(\"pointermove\", handlePointerMove, options);\r\n      }\r\n    });\r\n  }\r\n}\r\nfunction updateResizeHandlerStates(action, event) {\r\n  registeredResizeHandlers.forEach(data => {\r\n    const {\r\n      setResizeHandlerState\r\n    } = data;\r\n    const isActive = intersectingHandles.includes(data);\r\n    setResizeHandlerState(action, isActive, event);\r\n  });\r\n}\r\n\r\nfunction useForceUpdate() {\r\n  const [_, setCount] = useState(0);\r\n  return useCallback(() => setCount(prevCount => prevCount + 1), []);\r\n}\r\n\r\nfunction assert(expectedCondition, message) {\r\n  if (!expectedCondition) {\r\n    console.error(message);\r\n    throw Error(message);\r\n  }\r\n}\r\n\r\nfunction fuzzyCompareNumbers(actual, expected, fractionDigits = PRECISION) {\r\n  if (actual.toFixed(fractionDigits) === expected.toFixed(fractionDigits)) {\r\n    return 0;\r\n  } else {\r\n    return actual > expected ? 1 : -1;\r\n  }\r\n}\r\nfunction fuzzyNumbersEqual$1(actual, expected, fractionDigits = PRECISION) {\r\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\r\n}\r\n\r\nfunction fuzzyNumbersEqual(actual, expected, fractionDigits) {\r\n  return fuzzyCompareNumbers(actual, expected, fractionDigits) === 0;\r\n}\r\n\r\nfunction fuzzyLayoutsEqual(actual, expected, fractionDigits) {\r\n  if (actual.length !== expected.length) {\r\n    return false;\r\n  }\r\n  for (let index = 0; index < actual.length; index++) {\r\n    const actualSize = actual[index];\r\n    const expectedSize = expected[index];\r\n    if (!fuzzyNumbersEqual(actualSize, expectedSize, fractionDigits)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// Panel size must be in percentages; pixel values should be pre-converted\r\nfunction resizePanel({\r\n  panelConstraints: panelConstraintsArray,\r\n  panelIndex,\r\n  size\r\n}) {\r\n  const panelConstraints = panelConstraintsArray[panelIndex];\r\n  assert(panelConstraints != null, `Panel constraints not found for index ${panelIndex}`);\r\n  let {\r\n    collapsedSize = 0,\r\n    collapsible,\r\n    maxSize = 100,\r\n    minSize = 0\r\n  } = panelConstraints;\r\n  if (fuzzyCompareNumbers(size, minSize) < 0) {\r\n    if (collapsible) {\r\n      // Collapsible panels should snap closed or open only once they cross the halfway point between collapsed and min size.\r\n      const halfwayPoint = (collapsedSize + minSize) / 2;\r\n      if (fuzzyCompareNumbers(size, halfwayPoint) < 0) {\r\n        size = collapsedSize;\r\n      } else {\r\n        size = minSize;\r\n      }\r\n    } else {\r\n      size = minSize;\r\n    }\r\n  }\r\n  size = Math.min(maxSize, size);\r\n  size = parseFloat(size.toFixed(PRECISION));\r\n  return size;\r\n}\r\n\r\n// All units must be in percentages; pixel values should be pre-converted\r\nfunction adjustLayoutByDelta({\r\n  delta,\r\n  initialLayout,\r\n  panelConstraints: panelConstraintsArray,\r\n  pivotIndices,\r\n  prevLayout,\r\n  trigger\r\n}) {\r\n  if (fuzzyNumbersEqual(delta, 0)) {\r\n    return initialLayout;\r\n  }\r\n  const nextLayout = [...initialLayout];\r\n  const [firstPivotIndex, secondPivotIndex] = pivotIndices;\r\n  assert(firstPivotIndex != null, \"Invalid first pivot index\");\r\n  assert(secondPivotIndex != null, \"Invalid second pivot index\");\r\n  let deltaApplied = 0;\r\n\r\n  // const DEBUG = [];\r\n  // DEBUG.push(`adjustLayoutByDelta()`);\r\n  // DEBUG.push(`  initialLayout: ${initialLayout.join(\", \")}`);\r\n  // DEBUG.push(`  prevLayout: ${prevLayout.join(\", \")}`);\r\n  // DEBUG.push(`  delta: ${delta}`);\r\n  // DEBUG.push(`  pivotIndices: ${pivotIndices.join(\", \")}`);\r\n  // DEBUG.push(`  trigger: ${trigger}`);\r\n  // DEBUG.push(\"\");\r\n\r\n  // A resizing panel affects the panels before or after it.\r\n  //\r\n  // A negative delta means the panel(s) immediately after the resize handle should grow/expand by decreasing its offset.\r\n  // Other panels may also need to shrink/contract (and shift) to make room, depending on the min weights.\r\n  //\r\n  // A positive delta means the panel(s) immediately before the resize handle should \"expand\".\r\n  // This is accomplished by shrinking/contracting (and shifting) one or more of the panels after the resize handle.\r\n\r\n  {\r\n    // If this is a resize triggered by a keyboard event, our logic for expanding/collapsing is different.\r\n    // We no longer check the halfway threshold because this may prevent the panel from expanding at all.\r\n    if (trigger === \"keyboard\") {\r\n      {\r\n        // Check if we should expand a collapsed panel\r\n        const index = delta < 0 ? secondPivotIndex : firstPivotIndex;\r\n        const panelConstraints = panelConstraintsArray[index];\r\n        assert(panelConstraints, `Panel constraints not found for index ${index}`);\r\n        const {\r\n          collapsedSize = 0,\r\n          collapsible,\r\n          minSize = 0\r\n        } = panelConstraints;\r\n\r\n        // DEBUG.push(`edge case check 1: ${index}`);\r\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\r\n        if (collapsible) {\r\n          const prevSize = initialLayout[index];\r\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\r\n          if (fuzzyNumbersEqual(prevSize, collapsedSize)) {\r\n            const localDelta = minSize - prevSize;\r\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\r\n\r\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\r\n              delta = delta < 0 ? 0 - localDelta : localDelta;\r\n              // DEBUG.push(`  -> delta: ${delta}`);\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      {\r\n        // Check if we should collapse a panel at its minimum size\r\n        const index = delta < 0 ? firstPivotIndex : secondPivotIndex;\r\n        const panelConstraints = panelConstraintsArray[index];\r\n        assert(panelConstraints, `No panel constraints found for index ${index}`);\r\n        const {\r\n          collapsedSize = 0,\r\n          collapsible,\r\n          minSize = 0\r\n        } = panelConstraints;\r\n\r\n        // DEBUG.push(`edge case check 2: ${index}`);\r\n        // DEBUG.push(`  -> collapsible? ${collapsible}`);\r\n        if (collapsible) {\r\n          const prevSize = initialLayout[index];\r\n          assert(prevSize != null, `Previous layout not found for panel index ${index}`);\r\n          if (fuzzyNumbersEqual(prevSize, minSize)) {\r\n            const localDelta = prevSize - collapsedSize;\r\n            // DEBUG.push(`  -> expand delta: ${localDelta}`);\r\n\r\n            if (fuzzyCompareNumbers(localDelta, Math.abs(delta)) > 0) {\r\n              delta = delta < 0 ? 0 - localDelta : localDelta;\r\n              // DEBUG.push(`  -> delta: ${delta}`);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // DEBUG.push(\"\");\r\n  }\r\n\r\n  {\r\n    // Pre-calculate max available delta in the opposite direction of our pivot.\r\n    // This will be the maximum amount we're allowed to expand/contract the panels in the primary direction.\r\n    // If this amount is less than the requested delta, adjust the requested delta.\r\n    // If this amount is greater than the requested delta, that's useful information too–\r\n    // as an expanding panel might change from collapsed to min size.\r\n\r\n    const increment = delta < 0 ? 1 : -1;\r\n    let index = delta < 0 ? secondPivotIndex : firstPivotIndex;\r\n    let maxAvailableDelta = 0;\r\n\r\n    // DEBUG.push(\"pre calc...\");\r\n    while (true) {\r\n      const prevSize = initialLayout[index];\r\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\r\n      const maxSafeSize = resizePanel({\r\n        panelConstraints: panelConstraintsArray,\r\n        panelIndex: index,\r\n        size: 100\r\n      });\r\n      const delta = maxSafeSize - prevSize;\r\n      // DEBUG.push(`  ${index}: ${prevSize} -> ${maxSafeSize}`);\r\n\r\n      maxAvailableDelta += delta;\r\n      index += increment;\r\n      if (index < 0 || index >= panelConstraintsArray.length) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    // DEBUG.push(`  -> max available delta: ${maxAvailableDelta}`);\r\n    const minAbsDelta = Math.min(Math.abs(delta), Math.abs(maxAvailableDelta));\r\n    delta = delta < 0 ? 0 - minAbsDelta : minAbsDelta;\r\n    // DEBUG.push(`  -> adjusted delta: ${delta}`);\r\n    // DEBUG.push(\"\");\r\n  }\r\n\r\n  {\r\n    // Delta added to a panel needs to be subtracted from other panels (within the constraints that those panels allow).\r\n\r\n    const pivotIndex = delta < 0 ? firstPivotIndex : secondPivotIndex;\r\n    let index = pivotIndex;\r\n    while (index >= 0 && index < panelConstraintsArray.length) {\r\n      const deltaRemaining = Math.abs(delta) - Math.abs(deltaApplied);\r\n      const prevSize = initialLayout[index];\r\n      assert(prevSize != null, `Previous layout not found for panel index ${index}`);\r\n      const unsafeSize = prevSize - deltaRemaining;\r\n      const safeSize = resizePanel({\r\n        panelConstraints: panelConstraintsArray,\r\n        panelIndex: index,\r\n        size: unsafeSize\r\n      });\r\n      if (!fuzzyNumbersEqual(prevSize, safeSize)) {\r\n        deltaApplied += prevSize - safeSize;\r\n        nextLayout[index] = safeSize;\r\n        if (deltaApplied.toPrecision(3).localeCompare(Math.abs(delta).toPrecision(3), undefined, {\r\n          numeric: true\r\n        }) >= 0) {\r\n          break;\r\n        }\r\n      }\r\n      if (delta < 0) {\r\n        index--;\r\n      } else {\r\n        index++;\r\n      }\r\n    }\r\n  }\r\n  // DEBUG.push(`after 1: ${nextLayout.join(\", \")}`);\r\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\r\n  // DEBUG.push(\"\");\r\n\r\n  // If we were unable to resize any of the panels panels, return the previous state.\r\n  // This will essentially bailout and ignore e.g. drags past a panel's boundaries\r\n  if (fuzzyLayoutsEqual(prevLayout, nextLayout)) {\r\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\r\n    // console.log(DEBUG.join(\"\\n\"));\r\n\r\n    return prevLayout;\r\n  }\r\n  {\r\n    // Now distribute the applied delta to the panels in the other direction\r\n    const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\r\n    const prevSize = initialLayout[pivotIndex];\r\n    assert(prevSize != null, `Previous layout not found for panel index ${pivotIndex}`);\r\n    const unsafeSize = prevSize + deltaApplied;\r\n    const safeSize = resizePanel({\r\n      panelConstraints: panelConstraintsArray,\r\n      panelIndex: pivotIndex,\r\n      size: unsafeSize\r\n    });\r\n\r\n    // Adjust the pivot panel before, but only by the amount that surrounding panels were able to shrink/contract.\r\n    nextLayout[pivotIndex] = safeSize;\r\n\r\n    // Edge case where expanding or contracting one panel caused another one to change collapsed state\r\n    if (!fuzzyNumbersEqual(safeSize, unsafeSize)) {\r\n      let deltaRemaining = unsafeSize - safeSize;\r\n      const pivotIndex = delta < 0 ? secondPivotIndex : firstPivotIndex;\r\n      let index = pivotIndex;\r\n      while (index >= 0 && index < panelConstraintsArray.length) {\r\n        const prevSize = nextLayout[index];\r\n        assert(prevSize != null, `Previous layout not found for panel index ${index}`);\r\n        const unsafeSize = prevSize + deltaRemaining;\r\n        const safeSize = resizePanel({\r\n          panelConstraints: panelConstraintsArray,\r\n          panelIndex: index,\r\n          size: unsafeSize\r\n        });\r\n        if (!fuzzyNumbersEqual(prevSize, safeSize)) {\r\n          deltaRemaining -= safeSize - prevSize;\r\n          nextLayout[index] = safeSize;\r\n        }\r\n        if (fuzzyNumbersEqual(deltaRemaining, 0)) {\r\n          break;\r\n        }\r\n        if (delta > 0) {\r\n          index--;\r\n        } else {\r\n          index++;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // DEBUG.push(`after 2: ${nextLayout.join(\", \")}`);\r\n  // DEBUG.push(`  deltaApplied: ${deltaApplied}`);\r\n  // DEBUG.push(\"\");\r\n\r\n  const totalSize = nextLayout.reduce((total, size) => size + total, 0);\r\n  // DEBUG.push(`total size: ${totalSize}`);\r\n\r\n  // If our new layout doesn't add up to 100%, that means the requested delta can't be applied\r\n  // In that case, fall back to our most recent valid layout\r\n  if (!fuzzyNumbersEqual(totalSize, 100)) {\r\n    // DEBUG.push(`bailout to previous layout: ${prevLayout.join(\", \")}`);\r\n    // console.log(DEBUG.join(\"\\n\"));\r\n\r\n    return prevLayout;\r\n  }\r\n\r\n  // console.log(DEBUG.join(\"\\n\"));\r\n  return nextLayout;\r\n}\r\n\r\nfunction calculateAriaValues({\r\n  layout,\r\n  panelsArray,\r\n  pivotIndices\r\n}) {\r\n  let currentMinSize = 0;\r\n  let currentMaxSize = 100;\r\n  let totalMinSize = 0;\r\n  let totalMaxSize = 0;\r\n  const firstIndex = pivotIndices[0];\r\n  assert(firstIndex != null, \"No pivot index found\");\r\n\r\n  // A panel's effective min/max sizes also need to account for other panel's sizes.\r\n  panelsArray.forEach((panelData, index) => {\r\n    const {\r\n      constraints\r\n    } = panelData;\r\n    const {\r\n      maxSize = 100,\r\n      minSize = 0\r\n    } = constraints;\r\n    if (index === firstIndex) {\r\n      currentMinSize = minSize;\r\n      currentMaxSize = maxSize;\r\n    } else {\r\n      totalMinSize += minSize;\r\n      totalMaxSize += maxSize;\r\n    }\r\n  });\r\n  const valueMax = Math.min(currentMaxSize, 100 - totalMinSize);\r\n  const valueMin = Math.max(currentMinSize, 100 - totalMaxSize);\r\n  const valueNow = layout[firstIndex];\r\n  return {\r\n    valueMax,\r\n    valueMin,\r\n    valueNow\r\n  };\r\n}\r\n\r\nfunction getResizeHandleElementsForGroup(groupId, scope = document) {\r\n  return Array.from(scope.querySelectorAll(`[${DATA_ATTRIBUTES.resizeHandleId}][data-panel-group-id=\"${groupId}\"]`));\r\n}\r\n\r\nfunction getResizeHandleElementIndex(groupId, id, scope = document) {\r\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\r\n  const index = handles.findIndex(handle => handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId) === id);\r\n  return index !== null && index !== void 0 ? index : null;\r\n}\r\n\r\nfunction determinePivotIndices(groupId, dragHandleId, panelGroupElement) {\r\n  const index = getResizeHandleElementIndex(groupId, dragHandleId, panelGroupElement);\r\n  return index != null ? [index, index + 1] : [-1, -1];\r\n}\r\n\r\nfunction getPanelGroupElement(id, rootElement = document) {\r\n  var _dataset;\r\n  //If the root element is the PanelGroup\r\n  if (rootElement instanceof HTMLElement && (rootElement === null || rootElement === void 0 ? void 0 : (_dataset = rootElement.dataset) === null || _dataset === void 0 ? void 0 : _dataset.panelGroupId) == id) {\r\n    return rootElement;\r\n  }\r\n\r\n  //Else query children\r\n  const element = rootElement.querySelector(`[data-panel-group][data-panel-group-id=\"${id}\"]`);\r\n  if (element) {\r\n    return element;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction getResizeHandleElement(id, scope = document) {\r\n  const element = scope.querySelector(`[${DATA_ATTRIBUTES.resizeHandleId}=\"${id}\"]`);\r\n  if (element) {\r\n    return element;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction getResizeHandlePanelIds(groupId, handleId, panelsArray, scope = document) {\r\n  var _panelsArray$index$id, _panelsArray$index, _panelsArray$id, _panelsArray;\r\n  const handle = getResizeHandleElement(handleId, scope);\r\n  const handles = getResizeHandleElementsForGroup(groupId, scope);\r\n  const index = handle ? handles.indexOf(handle) : -1;\r\n  const idBefore = (_panelsArray$index$id = (_panelsArray$index = panelsArray[index]) === null || _panelsArray$index === void 0 ? void 0 : _panelsArray$index.id) !== null && _panelsArray$index$id !== void 0 ? _panelsArray$index$id : null;\r\n  const idAfter = (_panelsArray$id = (_panelsArray = panelsArray[index + 1]) === null || _panelsArray === void 0 ? void 0 : _panelsArray.id) !== null && _panelsArray$id !== void 0 ? _panelsArray$id : null;\r\n  return [idBefore, idAfter];\r\n}\r\n\r\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\r\n\r\nfunction useWindowSplitterPanelGroupBehavior({\r\n  committedValuesRef,\r\n  eagerValuesRef,\r\n  groupId,\r\n  layout,\r\n  panelDataArray,\r\n  panelGroupElement,\r\n  setLayout\r\n}) {\r\n  const devWarningsRef = useRef({\r\n    didWarnAboutMissingResizeHandle: false\r\n  });\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (!panelGroupElement) {\r\n      return;\r\n    }\r\n    const resizeHandleElements = getResizeHandleElementsForGroup(groupId, panelGroupElement);\r\n    for (let index = 0; index < panelDataArray.length - 1; index++) {\r\n      const {\r\n        valueMax,\r\n        valueMin,\r\n        valueNow\r\n      } = calculateAriaValues({\r\n        layout,\r\n        panelsArray: panelDataArray,\r\n        pivotIndices: [index, index + 1]\r\n      });\r\n      const resizeHandleElement = resizeHandleElements[index];\r\n      if (resizeHandleElement == null) {\r\n        {\r\n          const {\r\n            didWarnAboutMissingResizeHandle\r\n          } = devWarningsRef.current;\r\n          if (!didWarnAboutMissingResizeHandle) {\r\n            devWarningsRef.current.didWarnAboutMissingResizeHandle = true;\r\n            console.warn(`WARNING: Missing resize handle for PanelGroup \"${groupId}\"`);\r\n          }\r\n        }\r\n      } else {\r\n        const panelData = panelDataArray[index];\r\n        assert(panelData, `No panel data found for index \"${index}\"`);\r\n        resizeHandleElement.setAttribute(\"aria-controls\", panelData.id);\r\n        resizeHandleElement.setAttribute(\"aria-valuemax\", \"\" + Math.round(valueMax));\r\n        resizeHandleElement.setAttribute(\"aria-valuemin\", \"\" + Math.round(valueMin));\r\n        resizeHandleElement.setAttribute(\"aria-valuenow\", valueNow != null ? \"\" + Math.round(valueNow) : \"\");\r\n      }\r\n    }\r\n    return () => {\r\n      resizeHandleElements.forEach((resizeHandleElement, index) => {\r\n        resizeHandleElement.removeAttribute(\"aria-controls\");\r\n        resizeHandleElement.removeAttribute(\"aria-valuemax\");\r\n        resizeHandleElement.removeAttribute(\"aria-valuemin\");\r\n        resizeHandleElement.removeAttribute(\"aria-valuenow\");\r\n      });\r\n    };\r\n  }, [groupId, layout, panelDataArray, panelGroupElement]);\r\n  useEffect(() => {\r\n    if (!panelGroupElement) {\r\n      return;\r\n    }\r\n    const eagerValues = eagerValuesRef.current;\r\n    assert(eagerValues, `Eager values not found`);\r\n    const {\r\n      panelDataArray\r\n    } = eagerValues;\r\n    const groupElement = getPanelGroupElement(groupId, panelGroupElement);\r\n    assert(groupElement != null, `No group found for id \"${groupId}\"`);\r\n    const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\r\n    assert(handles, `No resize handles found for group id \"${groupId}\"`);\r\n    const cleanupFunctions = handles.map(handle => {\r\n      const handleId = handle.getAttribute(DATA_ATTRIBUTES.resizeHandleId);\r\n      assert(handleId, `Resize handle element has no handle id attribute`);\r\n      const [idBefore, idAfter] = getResizeHandlePanelIds(groupId, handleId, panelDataArray, panelGroupElement);\r\n      if (idBefore == null || idAfter == null) {\r\n        return () => {};\r\n      }\r\n      const onKeyDown = event => {\r\n        if (event.defaultPrevented) {\r\n          return;\r\n        }\r\n        switch (event.key) {\r\n          case \"Enter\":\r\n            {\r\n              event.preventDefault();\r\n              const index = panelDataArray.findIndex(panelData => panelData.id === idBefore);\r\n              if (index >= 0) {\r\n                const panelData = panelDataArray[index];\r\n                assert(panelData, `No panel data found for index ${index}`);\r\n                const size = layout[index];\r\n                const {\r\n                  collapsedSize = 0,\r\n                  collapsible,\r\n                  minSize = 0\r\n                } = panelData.constraints;\r\n                if (size != null && collapsible) {\r\n                  const nextLayout = adjustLayoutByDelta({\r\n                    delta: fuzzyNumbersEqual(size, collapsedSize) ? minSize - collapsedSize : collapsedSize - size,\r\n                    initialLayout: layout,\r\n                    panelConstraints: panelDataArray.map(panelData => panelData.constraints),\r\n                    pivotIndices: determinePivotIndices(groupId, handleId, panelGroupElement),\r\n                    prevLayout: layout,\r\n                    trigger: \"keyboard\"\r\n                  });\r\n                  if (layout !== nextLayout) {\r\n                    setLayout(nextLayout);\r\n                  }\r\n                }\r\n              }\r\n              break;\r\n            }\r\n        }\r\n      };\r\n      handle.addEventListener(\"keydown\", onKeyDown);\r\n      return () => {\r\n        handle.removeEventListener(\"keydown\", onKeyDown);\r\n      };\r\n    });\r\n    return () => {\r\n      cleanupFunctions.forEach(cleanupFunction => cleanupFunction());\r\n    };\r\n  }, [panelGroupElement, committedValuesRef, eagerValuesRef, groupId, layout, panelDataArray, setLayout]);\r\n}\r\n\r\nfunction areEqual(arrayA, arrayB) {\r\n  if (arrayA.length !== arrayB.length) {\r\n    return false;\r\n  }\r\n  for (let index = 0; index < arrayA.length; index++) {\r\n    if (arrayA[index] !== arrayB[index]) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nfunction getResizeEventCursorPosition(direction, event) {\r\n  const isHorizontal = direction === \"horizontal\";\r\n  const {\r\n    x,\r\n    y\r\n  } = getResizeEventCoordinates(event);\r\n  return isHorizontal ? x : y;\r\n}\r\n\r\nfunction calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement) {\r\n  const isHorizontal = direction === \"horizontal\";\r\n  const handleElement = getResizeHandleElement(dragHandleId, panelGroupElement);\r\n  assert(handleElement, `No resize handle element found for id \"${dragHandleId}\"`);\r\n  const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\r\n  assert(groupId, `Resize handle element has no group id attribute`);\r\n  let {\r\n    initialCursorPosition\r\n  } = initialDragState;\r\n  const cursorPosition = getResizeEventCursorPosition(direction, event);\r\n  const groupElement = getPanelGroupElement(groupId, panelGroupElement);\r\n  assert(groupElement, `No group element found for id \"${groupId}\"`);\r\n  const groupRect = groupElement.getBoundingClientRect();\r\n  const groupSizeInPixels = isHorizontal ? groupRect.width : groupRect.height;\r\n  const offsetPixels = cursorPosition - initialCursorPosition;\r\n  const offsetPercentage = offsetPixels / groupSizeInPixels * 100;\r\n  return offsetPercentage;\r\n}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/movementX\r\nfunction calculateDeltaPercentage(event, dragHandleId, direction, initialDragState, keyboardResizeBy, panelGroupElement) {\r\n  if (isKeyDown(event)) {\r\n    const isHorizontal = direction === \"horizontal\";\r\n    let delta = 0;\r\n    if (event.shiftKey) {\r\n      delta = 100;\r\n    } else if (keyboardResizeBy != null) {\r\n      delta = keyboardResizeBy;\r\n    } else {\r\n      delta = 10;\r\n    }\r\n    let movement = 0;\r\n    switch (event.key) {\r\n      case \"ArrowDown\":\r\n        movement = isHorizontal ? 0 : delta;\r\n        break;\r\n      case \"ArrowLeft\":\r\n        movement = isHorizontal ? -delta : 0;\r\n        break;\r\n      case \"ArrowRight\":\r\n        movement = isHorizontal ? delta : 0;\r\n        break;\r\n      case \"ArrowUp\":\r\n        movement = isHorizontal ? 0 : -delta;\r\n        break;\r\n      case \"End\":\r\n        movement = 100;\r\n        break;\r\n      case \"Home\":\r\n        movement = -100;\r\n        break;\r\n    }\r\n    return movement;\r\n  } else {\r\n    if (initialDragState == null) {\r\n      return 0;\r\n    }\r\n    return calculateDragOffsetPercentage(event, dragHandleId, direction, initialDragState, panelGroupElement);\r\n  }\r\n}\r\n\r\nfunction calculateUnsafeDefaultLayout({\r\n  panelDataArray\r\n}) {\r\n  const layout = Array(panelDataArray.length);\r\n  const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\r\n  let numPanelsWithSizes = 0;\r\n  let remainingSize = 100;\r\n\r\n  // Distribute default sizes first\r\n  for (let index = 0; index < panelDataArray.length; index++) {\r\n    const panelConstraints = panelConstraintsArray[index];\r\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\r\n    const {\r\n      defaultSize\r\n    } = panelConstraints;\r\n    if (defaultSize != null) {\r\n      numPanelsWithSizes++;\r\n      layout[index] = defaultSize;\r\n      remainingSize -= defaultSize;\r\n    }\r\n  }\r\n\r\n  // Remaining size should be distributed evenly between panels without default sizes\r\n  for (let index = 0; index < panelDataArray.length; index++) {\r\n    const panelConstraints = panelConstraintsArray[index];\r\n    assert(panelConstraints, `Panel constraints not found for index ${index}`);\r\n    const {\r\n      defaultSize\r\n    } = panelConstraints;\r\n    if (defaultSize != null) {\r\n      continue;\r\n    }\r\n    const numRemainingPanels = panelDataArray.length - numPanelsWithSizes;\r\n    const size = remainingSize / numRemainingPanels;\r\n    numPanelsWithSizes++;\r\n    layout[index] = size;\r\n    remainingSize -= size;\r\n  }\r\n  return layout;\r\n}\r\n\r\n// Layout should be pre-converted into percentages\r\nfunction callPanelCallbacks(panelsArray, layout, panelIdToLastNotifiedSizeMap) {\r\n  layout.forEach((size, index) => {\r\n    const panelData = panelsArray[index];\r\n    assert(panelData, `Panel data not found for index ${index}`);\r\n    const {\r\n      callbacks,\r\n      constraints,\r\n      id: panelId\r\n    } = panelData;\r\n    const {\r\n      collapsedSize = 0,\r\n      collapsible\r\n    } = constraints;\r\n    const lastNotifiedSize = panelIdToLastNotifiedSizeMap[panelId];\r\n    if (lastNotifiedSize == null || size !== lastNotifiedSize) {\r\n      panelIdToLastNotifiedSizeMap[panelId] = size;\r\n      const {\r\n        onCollapse,\r\n        onExpand,\r\n        onResize\r\n      } = callbacks;\r\n      if (onResize) {\r\n        onResize(size, lastNotifiedSize);\r\n      }\r\n      if (collapsible && (onCollapse || onExpand)) {\r\n        if (onExpand && (lastNotifiedSize == null || fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && !fuzzyNumbersEqual$1(size, collapsedSize)) {\r\n          onExpand();\r\n        }\r\n        if (onCollapse && (lastNotifiedSize == null || !fuzzyNumbersEqual$1(lastNotifiedSize, collapsedSize)) && fuzzyNumbersEqual$1(size, collapsedSize)) {\r\n          onCollapse();\r\n        }\r\n      }\r\n    }\r\n  });\r\n}\r\n\r\nfunction compareLayouts(a, b) {\r\n  if (a.length !== b.length) {\r\n    return false;\r\n  } else {\r\n    for (let index = 0; index < a.length; index++) {\r\n      if (a[index] != b[index]) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// This method returns a number between 1 and 100 representing\r\n\r\n// the % of the group's overall space this panel should occupy.\r\nfunction computePanelFlexBoxStyle({\r\n  defaultSize,\r\n  dragState,\r\n  layout,\r\n  panelData,\r\n  panelIndex,\r\n  precision = 3\r\n}) {\r\n  const size = layout[panelIndex];\r\n  let flexGrow;\r\n  if (size == null) {\r\n    // Initial render (before panels have registered themselves)\r\n    // In order to support server rendering, fall back to default size if provided\r\n    flexGrow = defaultSize != undefined ? defaultSize.toPrecision(precision) : \"1\";\r\n  } else if (panelData.length === 1) {\r\n    // Special case: Single panel group should always fill full width/height\r\n    flexGrow = \"1\";\r\n  } else {\r\n    flexGrow = size.toPrecision(precision);\r\n  }\r\n  return {\r\n    flexBasis: 0,\r\n    flexGrow,\r\n    flexShrink: 1,\r\n    // Without this, Panel sizes may be unintentionally overridden by their content\r\n    overflow: \"hidden\",\r\n    // Disable pointer events inside of a panel during resize\r\n    // This avoid edge cases like nested iframes\r\n    pointerEvents: dragState !== null ? \"none\" : undefined\r\n  };\r\n}\r\n\r\nfunction debounce(callback, durationMs = 10) {\r\n  let timeoutId = null;\r\n  let callable = (...args) => {\r\n    if (timeoutId !== null) {\r\n      clearTimeout(timeoutId);\r\n    }\r\n    timeoutId = setTimeout(() => {\r\n      callback(...args);\r\n    }, durationMs);\r\n  };\r\n  return callable;\r\n}\r\n\r\n// PanelGroup might be rendering in a server-side environment where localStorage is not available\r\n// or on a browser with cookies/storage disabled.\r\n// In either case, this function avoids accessing localStorage until needed,\r\n// and avoids throwing user-visible errors.\r\nfunction initializeDefaultStorage(storageObject) {\r\n  try {\r\n    if (typeof localStorage !== \"undefined\") {\r\n      // Bypass this check for future calls\r\n      storageObject.getItem = name => {\r\n        return localStorage.getItem(name);\r\n      };\r\n      storageObject.setItem = (name, value) => {\r\n        localStorage.setItem(name, value);\r\n      };\r\n    } else {\r\n      throw new Error(\"localStorage not supported in this environment\");\r\n    }\r\n  } catch (error) {\r\n    console.error(error);\r\n    storageObject.getItem = () => null;\r\n    storageObject.setItem = () => {};\r\n  }\r\n}\r\n\r\nfunction getPanelGroupKey(autoSaveId) {\r\n  return `react-resizable-panels:${autoSaveId}`;\r\n}\r\n\r\n// Note that Panel ids might be user-provided (stable) or useId generated (non-deterministic)\r\n// so they should not be used as part of the serialization key.\r\n// Using the min/max size attributes should work well enough as a backup.\r\n// Pre-sorting by minSize allows remembering layouts even if panels are re-ordered/dragged.\r\nfunction getPanelKey(panels) {\r\n  return panels.map(panel => {\r\n    const {\r\n      constraints,\r\n      id,\r\n      idIsFromProps,\r\n      order\r\n    } = panel;\r\n    if (idIsFromProps) {\r\n      return id;\r\n    } else {\r\n      return order ? `${order}:${JSON.stringify(constraints)}` : JSON.stringify(constraints);\r\n    }\r\n  }).sort((a, b) => a.localeCompare(b)).join(\",\");\r\n}\r\nfunction loadSerializedPanelGroupState(autoSaveId, storage) {\r\n  try {\r\n    const panelGroupKey = getPanelGroupKey(autoSaveId);\r\n    const serialized = storage.getItem(panelGroupKey);\r\n    if (serialized) {\r\n      const parsed = JSON.parse(serialized);\r\n      if (typeof parsed === \"object\" && parsed != null) {\r\n        return parsed;\r\n      }\r\n    }\r\n  } catch (error) {}\r\n  return null;\r\n}\r\nfunction loadPanelGroupState(autoSaveId, panels, storage) {\r\n  var _loadSerializedPanelG, _state$panelKey;\r\n  const state = (_loadSerializedPanelG = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG !== void 0 ? _loadSerializedPanelG : {};\r\n  const panelKey = getPanelKey(panels);\r\n  return (_state$panelKey = state[panelKey]) !== null && _state$panelKey !== void 0 ? _state$panelKey : null;\r\n}\r\nfunction savePanelGroupState(autoSaveId, panels, panelSizesBeforeCollapse, sizes, storage) {\r\n  var _loadSerializedPanelG2;\r\n  const panelGroupKey = getPanelGroupKey(autoSaveId);\r\n  const panelKey = getPanelKey(panels);\r\n  const state = (_loadSerializedPanelG2 = loadSerializedPanelGroupState(autoSaveId, storage)) !== null && _loadSerializedPanelG2 !== void 0 ? _loadSerializedPanelG2 : {};\r\n  state[panelKey] = {\r\n    expandToSizes: Object.fromEntries(panelSizesBeforeCollapse.entries()),\r\n    layout: sizes\r\n  };\r\n  try {\r\n    storage.setItem(panelGroupKey, JSON.stringify(state));\r\n  } catch (error) {\r\n    console.error(error);\r\n  }\r\n}\r\n\r\nfunction validatePanelConstraints({\r\n  panelConstraints: panelConstraintsArray,\r\n  panelId,\r\n  panelIndex\r\n}) {\r\n  {\r\n    const warnings = [];\r\n    const panelConstraints = panelConstraintsArray[panelIndex];\r\n    assert(panelConstraints, `No panel constraints found for index ${panelIndex}`);\r\n    const {\r\n      collapsedSize = 0,\r\n      collapsible = false,\r\n      defaultSize,\r\n      maxSize = 100,\r\n      minSize = 0\r\n    } = panelConstraints;\r\n    if (minSize > maxSize) {\r\n      warnings.push(`min size (${minSize}%) should not be greater than max size (${maxSize}%)`);\r\n    }\r\n    if (defaultSize != null) {\r\n      if (defaultSize < 0) {\r\n        warnings.push(\"default size should not be less than 0\");\r\n      } else if (defaultSize < minSize && (!collapsible || defaultSize !== collapsedSize)) {\r\n        warnings.push(\"default size should not be less than min size\");\r\n      }\r\n      if (defaultSize > 100) {\r\n        warnings.push(\"default size should not be greater than 100\");\r\n      } else if (defaultSize > maxSize) {\r\n        warnings.push(\"default size should not be greater than max size\");\r\n      }\r\n    }\r\n    if (collapsedSize > minSize) {\r\n      warnings.push(\"collapsed size should not be greater than min size\");\r\n    }\r\n    if (warnings.length > 0) {\r\n      const name = panelId != null ? `Panel \"${panelId}\"` : \"Panel\";\r\n      console.warn(`${name} has an invalid configuration:\\n\\n${warnings.join(\"\\n\")}`);\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\n// All units must be in percentages; pixel values should be pre-converted\r\nfunction validatePanelGroupLayout({\r\n  layout: prevLayout,\r\n  panelConstraints\r\n}) {\r\n  const nextLayout = [...prevLayout];\r\n  const nextLayoutTotalSize = nextLayout.reduce((accumulated, current) => accumulated + current, 0);\r\n\r\n  // Validate layout expectations\r\n  if (nextLayout.length !== panelConstraints.length) {\r\n    throw Error(`Invalid ${panelConstraints.length} panel layout: ${nextLayout.map(size => `${size}%`).join(\", \")}`);\r\n  } else if (!fuzzyNumbersEqual(nextLayoutTotalSize, 100) && nextLayout.length > 0) {\r\n    // This is not ideal so we should warn about it, but it may be recoverable in some cases\r\n    // (especially if the amount is small)\r\n    {\r\n      console.warn(`WARNING: Invalid layout total size: ${nextLayout.map(size => `${size}%`).join(\", \")}. Layout normalization will be applied.`);\r\n    }\r\n    for (let index = 0; index < panelConstraints.length; index++) {\r\n      const unsafeSize = nextLayout[index];\r\n      assert(unsafeSize != null, `No layout data found for index ${index}`);\r\n      const safeSize = 100 / nextLayoutTotalSize * unsafeSize;\r\n      nextLayout[index] = safeSize;\r\n    }\r\n  }\r\n  let remainingSize = 0;\r\n\r\n  // First pass: Validate the proposed layout given each panel's constraints\r\n  for (let index = 0; index < panelConstraints.length; index++) {\r\n    const unsafeSize = nextLayout[index];\r\n    assert(unsafeSize != null, `No layout data found for index ${index}`);\r\n    const safeSize = resizePanel({\r\n      panelConstraints,\r\n      panelIndex: index,\r\n      size: unsafeSize\r\n    });\r\n    if (unsafeSize != safeSize) {\r\n      remainingSize += unsafeSize - safeSize;\r\n      nextLayout[index] = safeSize;\r\n    }\r\n  }\r\n\r\n  // If there is additional, left over space, assign it to any panel(s) that permits it\r\n  // (It's not worth taking multiple additional passes to evenly distribute)\r\n  if (!fuzzyNumbersEqual(remainingSize, 0)) {\r\n    for (let index = 0; index < panelConstraints.length; index++) {\r\n      const prevSize = nextLayout[index];\r\n      assert(prevSize != null, `No layout data found for index ${index}`);\r\n      const unsafeSize = prevSize + remainingSize;\r\n      const safeSize = resizePanel({\r\n        panelConstraints,\r\n        panelIndex: index,\r\n        size: unsafeSize\r\n      });\r\n      if (prevSize !== safeSize) {\r\n        remainingSize -= safeSize - prevSize;\r\n        nextLayout[index] = safeSize;\r\n\r\n        // Once we've used up the remainder, bail\r\n        if (fuzzyNumbersEqual(remainingSize, 0)) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return nextLayout;\r\n}\r\n\r\nconst LOCAL_STORAGE_DEBOUNCE_INTERVAL = 100;\r\nconst defaultStorage = {\r\n  getItem: name => {\r\n    initializeDefaultStorage(defaultStorage);\r\n    return defaultStorage.getItem(name);\r\n  },\r\n  setItem: (name, value) => {\r\n    initializeDefaultStorage(defaultStorage);\r\n    defaultStorage.setItem(name, value);\r\n  }\r\n};\r\nconst debounceMap = {};\r\nfunction PanelGroupWithForwardedRef({\r\n  autoSaveId = null,\r\n  children,\r\n  className: classNameFromProps = \"\",\r\n  direction,\r\n  forwardedRef,\r\n  id: idFromProps = null,\r\n  onLayout = null,\r\n  keyboardResizeBy = null,\r\n  storage = defaultStorage,\r\n  style: styleFromProps,\r\n  tagName: Type = \"div\",\r\n  ...rest\r\n}) {\r\n  const groupId = useUniqueId(idFromProps);\r\n  const panelGroupElementRef = useRef(null);\r\n  const [dragState, setDragState] = useState(null);\r\n  const [layout, setLayout] = useState([]);\r\n  const forceUpdate = useForceUpdate();\r\n  const panelIdToLastNotifiedSizeMapRef = useRef({});\r\n  const panelSizeBeforeCollapseRef = useRef(new Map());\r\n  const prevDeltaRef = useRef(0);\r\n  const committedValuesRef = useRef({\r\n    autoSaveId,\r\n    direction,\r\n    dragState,\r\n    id: groupId,\r\n    keyboardResizeBy,\r\n    onLayout,\r\n    storage\r\n  });\r\n  const eagerValuesRef = useRef({\r\n    layout,\r\n    panelDataArray: [],\r\n    panelDataArrayChanged: false\r\n  });\r\n  const devWarningsRef = useRef({\r\n    didLogIdAndOrderWarning: false,\r\n    didLogPanelConstraintsWarning: false,\r\n    prevPanelIds: []\r\n  });\r\n  useImperativeHandle(forwardedRef, () => ({\r\n    getId: () => committedValuesRef.current.id,\r\n    getLayout: () => {\r\n      const {\r\n        layout\r\n      } = eagerValuesRef.current;\r\n      return layout;\r\n    },\r\n    setLayout: unsafeLayout => {\r\n      const {\r\n        onLayout\r\n      } = committedValuesRef.current;\r\n      const {\r\n        layout: prevLayout,\r\n        panelDataArray\r\n      } = eagerValuesRef.current;\r\n      const safeLayout = validatePanelGroupLayout({\r\n        layout: unsafeLayout,\r\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\r\n      });\r\n      if (!areEqual(prevLayout, safeLayout)) {\r\n        setLayout(safeLayout);\r\n        eagerValuesRef.current.layout = safeLayout;\r\n        if (onLayout) {\r\n          onLayout(safeLayout);\r\n        }\r\n        callPanelCallbacks(panelDataArray, safeLayout, panelIdToLastNotifiedSizeMapRef.current);\r\n      }\r\n    }\r\n  }), []);\r\n  useIsomorphicLayoutEffect(() => {\r\n    committedValuesRef.current.autoSaveId = autoSaveId;\r\n    committedValuesRef.current.direction = direction;\r\n    committedValuesRef.current.dragState = dragState;\r\n    committedValuesRef.current.id = groupId;\r\n    committedValuesRef.current.onLayout = onLayout;\r\n    committedValuesRef.current.storage = storage;\r\n  });\r\n  useWindowSplitterPanelGroupBehavior({\r\n    committedValuesRef,\r\n    eagerValuesRef,\r\n    groupId,\r\n    layout,\r\n    panelDataArray: eagerValuesRef.current.panelDataArray,\r\n    setLayout,\r\n    panelGroupElement: panelGroupElementRef.current\r\n  });\r\n  useEffect(() => {\r\n    const {\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n\r\n    // If this panel has been configured to persist sizing information, save sizes to local storage.\r\n    if (autoSaveId) {\r\n      if (layout.length === 0 || layout.length !== panelDataArray.length) {\r\n        return;\r\n      }\r\n      let debouncedSave = debounceMap[autoSaveId];\r\n\r\n      // Limit the frequency of localStorage updates.\r\n      if (debouncedSave == null) {\r\n        debouncedSave = debounce(savePanelGroupState, LOCAL_STORAGE_DEBOUNCE_INTERVAL);\r\n        debounceMap[autoSaveId] = debouncedSave;\r\n      }\r\n\r\n      // Clone mutable data before passing to the debounced function,\r\n      // else we run the risk of saving an incorrect combination of mutable and immutable values to state.\r\n      const clonedPanelDataArray = [...panelDataArray];\r\n      const clonedPanelSizesBeforeCollapse = new Map(panelSizeBeforeCollapseRef.current);\r\n      debouncedSave(autoSaveId, clonedPanelDataArray, clonedPanelSizesBeforeCollapse, layout, storage);\r\n    }\r\n  }, [autoSaveId, layout, storage]);\r\n\r\n  // DEV warnings\r\n  useEffect(() => {\r\n    {\r\n      const {\r\n        panelDataArray\r\n      } = eagerValuesRef.current;\r\n      const {\r\n        didLogIdAndOrderWarning,\r\n        didLogPanelConstraintsWarning,\r\n        prevPanelIds\r\n      } = devWarningsRef.current;\r\n      if (!didLogIdAndOrderWarning) {\r\n        const panelIds = panelDataArray.map(({\r\n          id\r\n        }) => id);\r\n        devWarningsRef.current.prevPanelIds = panelIds;\r\n        const panelsHaveChanged = prevPanelIds.length > 0 && !areEqual(prevPanelIds, panelIds);\r\n        if (panelsHaveChanged) {\r\n          if (panelDataArray.find(({\r\n            idIsFromProps,\r\n            order\r\n          }) => !idIsFromProps || order == null)) {\r\n            devWarningsRef.current.didLogIdAndOrderWarning = true;\r\n            console.warn(`WARNING: Panel id and order props recommended when panels are dynamically rendered`);\r\n          }\r\n        }\r\n      }\r\n      if (!didLogPanelConstraintsWarning) {\r\n        const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\r\n        for (let panelIndex = 0; panelIndex < panelConstraints.length; panelIndex++) {\r\n          const panelData = panelDataArray[panelIndex];\r\n          assert(panelData, `Panel data not found for index ${panelIndex}`);\r\n          const isValid = validatePanelConstraints({\r\n            panelConstraints,\r\n            panelId: panelData.id,\r\n            panelIndex\r\n          });\r\n          if (!isValid) {\r\n            devWarningsRef.current.didLogPanelConstraintsWarning = true;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n\r\n  // External APIs are safe to memoize via committed values ref\r\n  const collapsePanel = useCallback(panelData => {\r\n    const {\r\n      onLayout\r\n    } = committedValuesRef.current;\r\n    const {\r\n      layout: prevLayout,\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    if (panelData.constraints.collapsible) {\r\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\r\n      const {\r\n        collapsedSize = 0,\r\n        panelSize,\r\n        pivotIndices\r\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\r\n      assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\r\n      if (!fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\r\n        // Store size before collapse;\r\n        // This is the size that gets restored if the expand() API is used.\r\n        panelSizeBeforeCollapseRef.current.set(panelData.id, panelSize);\r\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\r\n        const delta = isLastPanel ? panelSize - collapsedSize : collapsedSize - panelSize;\r\n        const nextLayout = adjustLayoutByDelta({\r\n          delta,\r\n          initialLayout: prevLayout,\r\n          panelConstraints: panelConstraintsArray,\r\n          pivotIndices,\r\n          prevLayout,\r\n          trigger: \"imperative-api\"\r\n        });\r\n        if (!compareLayouts(prevLayout, nextLayout)) {\r\n          setLayout(nextLayout);\r\n          eagerValuesRef.current.layout = nextLayout;\r\n          if (onLayout) {\r\n            onLayout(nextLayout);\r\n          }\r\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\r\n        }\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // External APIs are safe to memoize via committed values ref\r\n  const expandPanel = useCallback((panelData, minSizeOverride) => {\r\n    const {\r\n      onLayout\r\n    } = committedValuesRef.current;\r\n    const {\r\n      layout: prevLayout,\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    if (panelData.constraints.collapsible) {\r\n      const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\r\n      const {\r\n        collapsedSize = 0,\r\n        panelSize = 0,\r\n        minSize: minSizeFromProps = 0,\r\n        pivotIndices\r\n      } = panelDataHelper(panelDataArray, panelData, prevLayout);\r\n      const minSize = minSizeOverride !== null && minSizeOverride !== void 0 ? minSizeOverride : minSizeFromProps;\r\n      if (fuzzyNumbersEqual$1(panelSize, collapsedSize)) {\r\n        // Restore this panel to the size it was before it was collapsed, if possible.\r\n        const prevPanelSize = panelSizeBeforeCollapseRef.current.get(panelData.id);\r\n        const baseSize = prevPanelSize != null && prevPanelSize >= minSize ? prevPanelSize : minSize;\r\n        const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\r\n        const delta = isLastPanel ? panelSize - baseSize : baseSize - panelSize;\r\n        const nextLayout = adjustLayoutByDelta({\r\n          delta,\r\n          initialLayout: prevLayout,\r\n          panelConstraints: panelConstraintsArray,\r\n          pivotIndices,\r\n          prevLayout,\r\n          trigger: \"imperative-api\"\r\n        });\r\n        if (!compareLayouts(prevLayout, nextLayout)) {\r\n          setLayout(nextLayout);\r\n          eagerValuesRef.current.layout = nextLayout;\r\n          if (onLayout) {\r\n            onLayout(nextLayout);\r\n          }\r\n          callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\r\n        }\r\n      }\r\n    }\r\n  }, []);\r\n\r\n  // External APIs are safe to memoize via committed values ref\r\n  const getPanelSize = useCallback(panelData => {\r\n    const {\r\n      layout,\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    const {\r\n      panelSize\r\n    } = panelDataHelper(panelDataArray, panelData, layout);\r\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\r\n    return panelSize;\r\n  }, []);\r\n\r\n  // This API should never read from committedValuesRef\r\n  const getPanelStyle = useCallback((panelData, defaultSize) => {\r\n    const {\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    const panelIndex = findPanelDataIndex(panelDataArray, panelData);\r\n    return computePanelFlexBoxStyle({\r\n      defaultSize,\r\n      dragState,\r\n      layout,\r\n      panelData: panelDataArray,\r\n      panelIndex\r\n    });\r\n  }, [dragState, layout]);\r\n\r\n  // External APIs are safe to memoize via committed values ref\r\n  const isPanelCollapsed = useCallback(panelData => {\r\n    const {\r\n      layout,\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    const {\r\n      collapsedSize = 0,\r\n      collapsible,\r\n      panelSize\r\n    } = panelDataHelper(panelDataArray, panelData, layout);\r\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\r\n    return collapsible === true && fuzzyNumbersEqual$1(panelSize, collapsedSize);\r\n  }, []);\r\n\r\n  // External APIs are safe to memoize via committed values ref\r\n  const isPanelExpanded = useCallback(panelData => {\r\n    const {\r\n      layout,\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    const {\r\n      collapsedSize = 0,\r\n      collapsible,\r\n      panelSize\r\n    } = panelDataHelper(panelDataArray, panelData, layout);\r\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\r\n    return !collapsible || fuzzyCompareNumbers(panelSize, collapsedSize) > 0;\r\n  }, []);\r\n  const registerPanel = useCallback(panelData => {\r\n    const {\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    panelDataArray.push(panelData);\r\n    panelDataArray.sort((panelA, panelB) => {\r\n      const orderA = panelA.order;\r\n      const orderB = panelB.order;\r\n      if (orderA == null && orderB == null) {\r\n        return 0;\r\n      } else if (orderA == null) {\r\n        return -1;\r\n      } else if (orderB == null) {\r\n        return 1;\r\n      } else {\r\n        return orderA - orderB;\r\n      }\r\n    });\r\n    eagerValuesRef.current.panelDataArrayChanged = true;\r\n    forceUpdate();\r\n  }, [forceUpdate]);\r\n\r\n  // (Re)calculate group layout whenever panels are registered or unregistered.\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  useIsomorphicLayoutEffect(() => {\r\n    if (eagerValuesRef.current.panelDataArrayChanged) {\r\n      eagerValuesRef.current.panelDataArrayChanged = false;\r\n      const {\r\n        autoSaveId,\r\n        onLayout,\r\n        storage\r\n      } = committedValuesRef.current;\r\n      const {\r\n        layout: prevLayout,\r\n        panelDataArray\r\n      } = eagerValuesRef.current;\r\n\r\n      // If this panel has been configured to persist sizing information,\r\n      // default size should be restored from local storage if possible.\r\n      let unsafeLayout = null;\r\n      if (autoSaveId) {\r\n        const state = loadPanelGroupState(autoSaveId, panelDataArray, storage);\r\n        if (state) {\r\n          panelSizeBeforeCollapseRef.current = new Map(Object.entries(state.expandToSizes));\r\n          unsafeLayout = state.layout;\r\n        }\r\n      }\r\n      if (unsafeLayout == null) {\r\n        unsafeLayout = calculateUnsafeDefaultLayout({\r\n          panelDataArray\r\n        });\r\n      }\r\n\r\n      // Validate even saved layouts in case something has changed since last render\r\n      // e.g. for pixel groups, this could be the size of the window\r\n      const nextLayout = validatePanelGroupLayout({\r\n        layout: unsafeLayout,\r\n        panelConstraints: panelDataArray.map(panelData => panelData.constraints)\r\n      });\r\n      if (!areEqual(prevLayout, nextLayout)) {\r\n        setLayout(nextLayout);\r\n        eagerValuesRef.current.layout = nextLayout;\r\n        if (onLayout) {\r\n          onLayout(nextLayout);\r\n        }\r\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\r\n      }\r\n    }\r\n  });\r\n\r\n  // Reset the cached layout if hidden by the Activity/Offscreen API\r\n  useIsomorphicLayoutEffect(() => {\r\n    const eagerValues = eagerValuesRef.current;\r\n    return () => {\r\n      eagerValues.layout = [];\r\n    };\r\n  }, []);\r\n  const registerResizeHandle = useCallback(dragHandleId => {\r\n    let isRTL = false;\r\n    const panelGroupElement = panelGroupElementRef.current;\r\n    if (panelGroupElement) {\r\n      const style = window.getComputedStyle(panelGroupElement, null);\r\n      if (style.getPropertyValue(\"direction\") === \"rtl\") {\r\n        isRTL = true;\r\n      }\r\n    }\r\n    return function resizeHandler(event) {\r\n      event.preventDefault();\r\n      const panelGroupElement = panelGroupElementRef.current;\r\n      if (!panelGroupElement) {\r\n        return () => null;\r\n      }\r\n      const {\r\n        direction,\r\n        dragState,\r\n        id: groupId,\r\n        keyboardResizeBy,\r\n        onLayout\r\n      } = committedValuesRef.current;\r\n      const {\r\n        layout: prevLayout,\r\n        panelDataArray\r\n      } = eagerValuesRef.current;\r\n      const {\r\n        initialLayout\r\n      } = dragState !== null && dragState !== void 0 ? dragState : {};\r\n      const pivotIndices = determinePivotIndices(groupId, dragHandleId, panelGroupElement);\r\n      let delta = calculateDeltaPercentage(event, dragHandleId, direction, dragState, keyboardResizeBy, panelGroupElement);\r\n      const isHorizontal = direction === \"horizontal\";\r\n      if (isHorizontal && isRTL) {\r\n        delta = -delta;\r\n      }\r\n      const panelConstraints = panelDataArray.map(panelData => panelData.constraints);\r\n      const nextLayout = adjustLayoutByDelta({\r\n        delta,\r\n        initialLayout: initialLayout !== null && initialLayout !== void 0 ? initialLayout : prevLayout,\r\n        panelConstraints,\r\n        pivotIndices,\r\n        prevLayout,\r\n        trigger: isKeyDown(event) ? \"keyboard\" : \"mouse-or-touch\"\r\n      });\r\n      const layoutChanged = !compareLayouts(prevLayout, nextLayout);\r\n\r\n      // Only update the cursor for layout changes triggered by touch/mouse events (not keyboard)\r\n      // Update the cursor even if the layout hasn't changed (we may need to show an invalid cursor state)\r\n      if (isPointerEvent(event) || isMouseEvent(event)) {\r\n        // Watch for multiple subsequent deltas; this might occur for tiny cursor movements.\r\n        // In this case, Panel sizes might not change–\r\n        // but updating cursor in this scenario would cause a flicker.\r\n        if (prevDeltaRef.current != delta) {\r\n          prevDeltaRef.current = delta;\r\n          if (!layoutChanged && delta !== 0) {\r\n            // If the pointer has moved too far to resize the panel any further, note this so we can update the cursor.\r\n            // This mimics VS Code behavior.\r\n            if (isHorizontal) {\r\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_HORIZONTAL_MIN : EXCEEDED_HORIZONTAL_MAX);\r\n            } else {\r\n              reportConstraintsViolation(dragHandleId, delta < 0 ? EXCEEDED_VERTICAL_MIN : EXCEEDED_VERTICAL_MAX);\r\n            }\r\n          } else {\r\n            reportConstraintsViolation(dragHandleId, 0);\r\n          }\r\n        }\r\n      }\r\n      if (layoutChanged) {\r\n        setLayout(nextLayout);\r\n        eagerValuesRef.current.layout = nextLayout;\r\n        if (onLayout) {\r\n          onLayout(nextLayout);\r\n        }\r\n        callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // External APIs are safe to memoize via committed values ref\r\n  const resizePanel = useCallback((panelData, unsafePanelSize) => {\r\n    const {\r\n      onLayout\r\n    } = committedValuesRef.current;\r\n    const {\r\n      layout: prevLayout,\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    const panelConstraintsArray = panelDataArray.map(panelData => panelData.constraints);\r\n    const {\r\n      panelSize,\r\n      pivotIndices\r\n    } = panelDataHelper(panelDataArray, panelData, prevLayout);\r\n    assert(panelSize != null, `Panel size not found for panel \"${panelData.id}\"`);\r\n    const isLastPanel = findPanelDataIndex(panelDataArray, panelData) === panelDataArray.length - 1;\r\n    const delta = isLastPanel ? panelSize - unsafePanelSize : unsafePanelSize - panelSize;\r\n    const nextLayout = adjustLayoutByDelta({\r\n      delta,\r\n      initialLayout: prevLayout,\r\n      panelConstraints: panelConstraintsArray,\r\n      pivotIndices,\r\n      prevLayout,\r\n      trigger: \"imperative-api\"\r\n    });\r\n    if (!compareLayouts(prevLayout, nextLayout)) {\r\n      setLayout(nextLayout);\r\n      eagerValuesRef.current.layout = nextLayout;\r\n      if (onLayout) {\r\n        onLayout(nextLayout);\r\n      }\r\n      callPanelCallbacks(panelDataArray, nextLayout, panelIdToLastNotifiedSizeMapRef.current);\r\n    }\r\n  }, []);\r\n  const reevaluatePanelConstraints = useCallback((panelData, prevConstraints) => {\r\n    const {\r\n      layout,\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    const {\r\n      collapsedSize: prevCollapsedSize = 0,\r\n      collapsible: prevCollapsible\r\n    } = prevConstraints;\r\n    const {\r\n      collapsedSize: nextCollapsedSize = 0,\r\n      collapsible: nextCollapsible,\r\n      maxSize: nextMaxSize = 100,\r\n      minSize: nextMinSize = 0\r\n    } = panelData.constraints;\r\n    const {\r\n      panelSize: prevPanelSize\r\n    } = panelDataHelper(panelDataArray, panelData, layout);\r\n    if (prevPanelSize == null) {\r\n      // It's possible that the panels in this group have changed since the last render\r\n      return;\r\n    }\r\n    if (prevCollapsible && nextCollapsible && fuzzyNumbersEqual$1(prevPanelSize, prevCollapsedSize)) {\r\n      if (!fuzzyNumbersEqual$1(prevCollapsedSize, nextCollapsedSize)) {\r\n        resizePanel(panelData, nextCollapsedSize);\r\n      }\r\n    } else if (prevPanelSize < nextMinSize) {\r\n      resizePanel(panelData, nextMinSize);\r\n    } else if (prevPanelSize > nextMaxSize) {\r\n      resizePanel(panelData, nextMaxSize);\r\n    }\r\n  }, [resizePanel]);\r\n\r\n  // TODO Multiple drag handles can be active at the same time so this API is a bit awkward now\r\n  const startDragging = useCallback((dragHandleId, event) => {\r\n    const {\r\n      direction\r\n    } = committedValuesRef.current;\r\n    const {\r\n      layout\r\n    } = eagerValuesRef.current;\r\n    if (!panelGroupElementRef.current) {\r\n      return;\r\n    }\r\n    const handleElement = getResizeHandleElement(dragHandleId, panelGroupElementRef.current);\r\n    assert(handleElement, `Drag handle element not found for id \"${dragHandleId}\"`);\r\n    const initialCursorPosition = getResizeEventCursorPosition(direction, event);\r\n    setDragState({\r\n      dragHandleId,\r\n      dragHandleRect: handleElement.getBoundingClientRect(),\r\n      initialCursorPosition,\r\n      initialLayout: layout\r\n    });\r\n  }, []);\r\n  const stopDragging = useCallback(() => {\r\n    setDragState(null);\r\n  }, []);\r\n  const unregisterPanel = useCallback(panelData => {\r\n    const {\r\n      panelDataArray\r\n    } = eagerValuesRef.current;\r\n    const index = findPanelDataIndex(panelDataArray, panelData);\r\n    if (index >= 0) {\r\n      panelDataArray.splice(index, 1);\r\n\r\n      // TRICKY\r\n      // When a panel is removed from the group, we should delete the most recent prev-size entry for it.\r\n      // If we don't do this, then a conditionally rendered panel might not call onResize when it's re-mounted.\r\n      // Strict effects mode makes this tricky though because all panels will be registered, unregistered, then re-registered on mount.\r\n      delete panelIdToLastNotifiedSizeMapRef.current[panelData.id];\r\n      eagerValuesRef.current.panelDataArrayChanged = true;\r\n      forceUpdate();\r\n    }\r\n  }, [forceUpdate]);\r\n  const context = useMemo(() => ({\r\n    collapsePanel,\r\n    direction,\r\n    dragState,\r\n    expandPanel,\r\n    getPanelSize,\r\n    getPanelStyle,\r\n    groupId,\r\n    isPanelCollapsed,\r\n    isPanelExpanded,\r\n    reevaluatePanelConstraints,\r\n    registerPanel,\r\n    registerResizeHandle,\r\n    resizePanel,\r\n    startDragging,\r\n    stopDragging,\r\n    unregisterPanel,\r\n    panelGroupElement: panelGroupElementRef.current\r\n  }), [collapsePanel, dragState, direction, expandPanel, getPanelSize, getPanelStyle, groupId, isPanelCollapsed, isPanelExpanded, reevaluatePanelConstraints, registerPanel, registerResizeHandle, resizePanel, startDragging, stopDragging, unregisterPanel]);\r\n  const style = {\r\n    display: \"flex\",\r\n    flexDirection: direction === \"horizontal\" ? \"row\" : \"column\",\r\n    height: \"100%\",\r\n    overflow: \"hidden\",\r\n    width: \"100%\"\r\n  };\r\n  return createElement(PanelGroupContext.Provider, {\r\n    value: context\r\n  }, createElement(Type, {\r\n    ...rest,\r\n    children,\r\n    className: classNameFromProps,\r\n    id: idFromProps,\r\n    ref: panelGroupElementRef,\r\n    style: {\r\n      ...style,\r\n      ...styleFromProps\r\n    },\r\n    // CSS selectors\r\n    [DATA_ATTRIBUTES.group]: \"\",\r\n    [DATA_ATTRIBUTES.groupDirection]: direction,\r\n    [DATA_ATTRIBUTES.groupId]: groupId\r\n  }));\r\n}\r\nconst PanelGroup = forwardRef((props, ref) => createElement(PanelGroupWithForwardedRef, {\r\n  ...props,\r\n  forwardedRef: ref\r\n}));\r\nPanelGroupWithForwardedRef.displayName = \"PanelGroup\";\r\nPanelGroup.displayName = \"forwardRef(PanelGroup)\";\r\nfunction findPanelDataIndex(panelDataArray, panelData) {\r\n  return panelDataArray.findIndex(prevPanelData => prevPanelData === panelData || prevPanelData.id === panelData.id);\r\n}\r\nfunction panelDataHelper(panelDataArray, panelData, layout) {\r\n  const panelIndex = findPanelDataIndex(panelDataArray, panelData);\r\n  const isLastPanel = panelIndex === panelDataArray.length - 1;\r\n  const pivotIndices = isLastPanel ? [panelIndex - 1, panelIndex] : [panelIndex, panelIndex + 1];\r\n  const panelSize = layout[panelIndex];\r\n  return {\r\n    ...panelData.constraints,\r\n    panelSize,\r\n    pivotIndices\r\n  };\r\n}\r\n\r\n// https://www.w3.org/WAI/ARIA/apg/patterns/windowsplitter/\r\n\r\nfunction useWindowSplitterResizeHandlerBehavior({\r\n  disabled,\r\n  handleId,\r\n  resizeHandler,\r\n  panelGroupElement\r\n}) {\r\n  useEffect(() => {\r\n    if (disabled || resizeHandler == null || panelGroupElement == null) {\r\n      return;\r\n    }\r\n    const handleElement = getResizeHandleElement(handleId, panelGroupElement);\r\n    if (handleElement == null) {\r\n      return;\r\n    }\r\n    const onKeyDown = event => {\r\n      if (event.defaultPrevented) {\r\n        return;\r\n      }\r\n      switch (event.key) {\r\n        case \"ArrowDown\":\r\n        case \"ArrowLeft\":\r\n        case \"ArrowRight\":\r\n        case \"ArrowUp\":\r\n        case \"End\":\r\n        case \"Home\":\r\n          {\r\n            event.preventDefault();\r\n            resizeHandler(event);\r\n            break;\r\n          }\r\n        case \"F6\":\r\n          {\r\n            event.preventDefault();\r\n            const groupId = handleElement.getAttribute(DATA_ATTRIBUTES.groupId);\r\n            assert(groupId, `No group element found for id \"${groupId}\"`);\r\n            const handles = getResizeHandleElementsForGroup(groupId, panelGroupElement);\r\n            const index = getResizeHandleElementIndex(groupId, handleId, panelGroupElement);\r\n            assert(index !== null, `No resize element found for id \"${handleId}\"`);\r\n            const nextIndex = event.shiftKey ? index > 0 ? index - 1 : handles.length - 1 : index + 1 < handles.length ? index + 1 : 0;\r\n            const nextHandle = handles[nextIndex];\r\n            nextHandle.focus();\r\n            break;\r\n          }\r\n      }\r\n    };\r\n    handleElement.addEventListener(\"keydown\", onKeyDown);\r\n    return () => {\r\n      handleElement.removeEventListener(\"keydown\", onKeyDown);\r\n    };\r\n  }, [panelGroupElement, disabled, handleId, resizeHandler]);\r\n}\r\n\r\nfunction PanelResizeHandle({\r\n  children = null,\r\n  className: classNameFromProps = \"\",\r\n  disabled = false,\r\n  hitAreaMargins,\r\n  id: idFromProps,\r\n  onBlur,\r\n  onClick,\r\n  onDragging,\r\n  onFocus,\r\n  onPointerDown,\r\n  onPointerUp,\r\n  style: styleFromProps = {},\r\n  tabIndex = 0,\r\n  tagName: Type = \"div\",\r\n  ...rest\r\n}) {\r\n  var _hitAreaMargins$coars, _hitAreaMargins$fine;\r\n  const elementRef = useRef(null);\r\n\r\n  // Use a ref to guard against users passing inline props\r\n  const callbacksRef = useRef({\r\n    onClick,\r\n    onDragging,\r\n    onPointerDown,\r\n    onPointerUp\r\n  });\r\n  useEffect(() => {\r\n    callbacksRef.current.onClick = onClick;\r\n    callbacksRef.current.onDragging = onDragging;\r\n    callbacksRef.current.onPointerDown = onPointerDown;\r\n    callbacksRef.current.onPointerUp = onPointerUp;\r\n  });\r\n  const panelGroupContext = useContext(PanelGroupContext);\r\n  if (panelGroupContext === null) {\r\n    throw Error(`PanelResizeHandle components must be rendered within a PanelGroup container`);\r\n  }\r\n  const {\r\n    direction,\r\n    groupId,\r\n    registerResizeHandle: registerResizeHandleWithParentGroup,\r\n    startDragging,\r\n    stopDragging,\r\n    panelGroupElement\r\n  } = panelGroupContext;\r\n  const resizeHandleId = useUniqueId(idFromProps);\r\n  const [state, setState] = useState(\"inactive\");\r\n  const [isFocused, setIsFocused] = useState(false);\r\n  const [resizeHandler, setResizeHandler] = useState(null);\r\n  const committedValuesRef = useRef({\r\n    state\r\n  });\r\n  useIsomorphicLayoutEffect(() => {\r\n    committedValuesRef.current.state = state;\r\n  });\r\n  useEffect(() => {\r\n    if (disabled) {\r\n      setResizeHandler(null);\r\n    } else {\r\n      const resizeHandler = registerResizeHandleWithParentGroup(resizeHandleId);\r\n      setResizeHandler(() => resizeHandler);\r\n    }\r\n  }, [disabled, resizeHandleId, registerResizeHandleWithParentGroup]);\r\n\r\n  // Extract hit area margins before passing them to the effect's dependency array\r\n  // so that inline object values won't trigger re-renders\r\n  const coarseHitAreaMargins = (_hitAreaMargins$coars = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.coarse) !== null && _hitAreaMargins$coars !== void 0 ? _hitAreaMargins$coars : 15;\r\n  const fineHitAreaMargins = (_hitAreaMargins$fine = hitAreaMargins === null || hitAreaMargins === void 0 ? void 0 : hitAreaMargins.fine) !== null && _hitAreaMargins$fine !== void 0 ? _hitAreaMargins$fine : 5;\r\n  useEffect(() => {\r\n    if (disabled || resizeHandler == null) {\r\n      return;\r\n    }\r\n    const element = elementRef.current;\r\n    assert(element, \"Element ref not attached\");\r\n    let didMove = false;\r\n    const setResizeHandlerState = (action, isActive, event) => {\r\n      if (!isActive) {\r\n        setState(\"inactive\");\r\n        return;\r\n      }\r\n      switch (action) {\r\n        case \"down\":\r\n          {\r\n            setState(\"drag\");\r\n            didMove = false;\r\n            assert(event, 'Expected event to be defined for \"down\" action');\r\n            startDragging(resizeHandleId, event);\r\n            const {\r\n              onDragging,\r\n              onPointerDown\r\n            } = callbacksRef.current;\r\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(true);\r\n            onPointerDown === null || onPointerDown === void 0 ? void 0 : onPointerDown();\r\n            break;\r\n          }\r\n        case \"move\":\r\n          {\r\n            const {\r\n              state\r\n            } = committedValuesRef.current;\r\n            didMove = true;\r\n            if (state !== \"drag\") {\r\n              setState(\"hover\");\r\n            }\r\n            assert(event, 'Expected event to be defined for \"move\" action');\r\n            resizeHandler(event);\r\n            break;\r\n          }\r\n        case \"up\":\r\n          {\r\n            setState(\"hover\");\r\n            stopDragging();\r\n            const {\r\n              onClick,\r\n              onDragging,\r\n              onPointerUp\r\n            } = callbacksRef.current;\r\n            onDragging === null || onDragging === void 0 ? void 0 : onDragging(false);\r\n            onPointerUp === null || onPointerUp === void 0 ? void 0 : onPointerUp();\r\n            if (!didMove) {\r\n              onClick === null || onClick === void 0 ? void 0 : onClick();\r\n            }\r\n            break;\r\n          }\r\n      }\r\n    };\r\n    return registerResizeHandle(resizeHandleId, element, direction, {\r\n      coarse: coarseHitAreaMargins,\r\n      fine: fineHitAreaMargins\r\n    }, setResizeHandlerState);\r\n  }, [coarseHitAreaMargins, direction, disabled, fineHitAreaMargins, registerResizeHandleWithParentGroup, resizeHandleId, resizeHandler, startDragging, stopDragging]);\r\n  useWindowSplitterResizeHandlerBehavior({\r\n    disabled,\r\n    handleId: resizeHandleId,\r\n    resizeHandler,\r\n    panelGroupElement\r\n  });\r\n  const style = {\r\n    touchAction: \"none\",\r\n    userSelect: \"none\"\r\n  };\r\n  return createElement(Type, {\r\n    ...rest,\r\n    children,\r\n    className: classNameFromProps,\r\n    id: idFromProps,\r\n    onBlur: () => {\r\n      setIsFocused(false);\r\n      onBlur === null || onBlur === void 0 ? void 0 : onBlur();\r\n    },\r\n    onFocus: () => {\r\n      setIsFocused(true);\r\n      onFocus === null || onFocus === void 0 ? void 0 : onFocus();\r\n    },\r\n    ref: elementRef,\r\n    role: \"separator\",\r\n    style: {\r\n      ...style,\r\n      ...styleFromProps\r\n    },\r\n    tabIndex,\r\n    // CSS selectors\r\n    [DATA_ATTRIBUTES.groupDirection]: direction,\r\n    [DATA_ATTRIBUTES.groupId]: groupId,\r\n    [DATA_ATTRIBUTES.resizeHandle]: \"\",\r\n    [DATA_ATTRIBUTES.resizeHandleActive]: state === \"drag\" ? \"pointer\" : isFocused ? \"keyboard\" : undefined,\r\n    [DATA_ATTRIBUTES.resizeHandleEnabled]: !disabled,\r\n    [DATA_ATTRIBUTES.resizeHandleId]: resizeHandleId,\r\n    [DATA_ATTRIBUTES.resizeHandleState]: state\r\n  });\r\n}\r\nPanelResizeHandle.displayName = \"PanelResizeHandle\";\r\n\r\nfunction getPanelElement(id, scope = document) {\r\n  const element = scope.querySelector(`[data-panel-id=\"${id}\"]`);\r\n  if (element) {\r\n    return element;\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction getPanelElementsForGroup(groupId, scope = document) {\r\n  return Array.from(scope.querySelectorAll(`[data-panel][data-panel-group-id=\"${groupId}\"]`));\r\n}\r\n\r\nfunction getIntersectingRectangle(rectOne, rectTwo, strict) {\r\n  if (!intersects(rectOne, rectTwo, strict)) {\r\n    return {\r\n      x: 0,\r\n      y: 0,\r\n      width: 0,\r\n      height: 0\r\n    };\r\n  }\r\n  return {\r\n    x: Math.max(rectOne.x, rectTwo.x),\r\n    y: Math.max(rectOne.y, rectTwo.y),\r\n    width: Math.min(rectOne.x + rectOne.width, rectTwo.x + rectTwo.width) - Math.max(rectOne.x, rectTwo.x),\r\n    height: Math.min(rectOne.y + rectOne.height, rectTwo.y + rectTwo.height) - Math.max(rectOne.y, rectTwo.y)\r\n  };\r\n}\r\n\r\nexport { DATA_ATTRIBUTES, Panel, PanelGroup, PanelResizeHandle, assert, disableGlobalCursorStyles, enableGlobalCursorStyles, getIntersectingRectangle, getPanelElement, getPanelElementsForGroup, getPanelGroupElement, getResizeHandleElement, getResizeHandleElementIndex, getResizeHandleElementsForGroup, getResizeHandlePanelIds, intersects, setNonce };\r\n"],
  "mappings": "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",
  "names": ["resizePanel", "minSize", "props", "nonce", "count", "delta", "pivotIndex", "prevSize", "unsafeSize", "safeSize", "panelDataArray", "panelData", "layout", "onLayout", "autoSaveId", "storage", "registerResizeHandle", "style", "panelGroupElement", "direction", "dragState", "groupId", "keyboardResizeBy", "resizeHandler", "onDragging", "onPointerDown", "state", "onClick", "onPointerUp"]
}
